
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>SoyFinance</title>
        <link rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown-dark.min.css">
        <style>
    body {
      background: #0d1117;
      margin: 20px;
    }
  </style>
    </head>
    <body>
        <article class="markdown-body">
            <h1 id="report">Report</h1>
            <h2 id="gas-optimizations">Gas Optimizations</h2>
            <table>
                <thead>
                    <tr class="header">
                        <th></th>
                        <th style="text-align: left;">Issue</th>
                        <th style="text-align: center;">Instances</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="odd">
                        <td><a href="#GAS-1">GAS-1</a></td>
                        <td style="text-align: left;">Use <code>selfbalance()</code>
                            instead of
                            <code>address(this).balance</code></td>
                        <td style="text-align: center;">4</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#GAS-2">GAS-2</a></td>
                        <td style="text-align: left;">Use assembly to check for
                            <code>address(0)</code></td>
                        <td style="text-align: center;">25</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#GAS-3">GAS-3</a></td>
                        <td style="text-align: left;"><code>array[index] +=
                                amount</code> is
                            cheaper than <code>array[index] = array[index] +
                                amount</code> (or
                            related variants)</td>
                        <td style="text-align: center;">4</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#GAS-4">GAS-4</a></td>
                        <td style="text-align: left;">Using bools for storage
                            incurs
                            overhead</td>
                        <td style="text-align: center;">12</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#GAS-5">GAS-5</a></td>
                        <td style="text-align: left;">Cache array length outside
                            of loop</td>
                        <td style="text-align: center;">24</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#GAS-6">GAS-6</a></td>
                        <td style="text-align: left;">State variables should be
                            cached in stack
                            variables rather than re-reading them from storage</td>
                        <td style="text-align: center;">3</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#GAS-7">GAS-7</a></td>
                        <td style="text-align: left;">Use calldata instead of
                            memory for
                            function arguments that do not get mutated</td>
                        <td style="text-align: center;">10</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#GAS-8">GAS-8</a></td>
                        <td style="text-align: left;">For Operations that will
                            not overflow, you
                            could use unchecked</td>
                        <td style="text-align: center;">2114</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#GAS-9">GAS-9</a></td>
                        <td style="text-align: left;">Use Custom Errors</td>
                        <td style="text-align: center;">316</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#GAS-10">GAS-10</a></td>
                        <td style="text-align: left;">Don't initialize variables
                            with default
                            value</td>
                        <td style="text-align: center;">30</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#GAS-11">GAS-11</a></td>
                        <td style="text-align: left;">Long revert strings</td>
                        <td style="text-align: center;">148</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#GAS-12">GAS-12</a></td>
                        <td style="text-align: left;">Functions guaranteed to
                            revert when called
                            by normal users can be marked <code>payable</code></td>
                        <td style="text-align: center;">130</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#GAS-13">GAS-13</a></td>
                        <td style="text-align: left;"><code>++i</code> costs
                            less gas than
                            <code>i++</code>, especially when it's used in <code>for</code>-loops
                            (<code>--i</code>/<code>i--</code> too)</td>
                        <td style="text-align: center;">56</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#GAS-14">GAS-14</a></td>
                        <td style="text-align: left;">Using <code>private</code>
                            rather than
                            <code>public</code> for constants, saves gas</td>
                        <td style="text-align: center;">49</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#GAS-15">GAS-15</a></td>
                        <td style="text-align: left;">Use shift Right/Left
                            instead of
                            division/multiplication if possible</td>
                        <td style="text-align: center;">4</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#GAS-16">GAS-16</a></td>
                        <td style="text-align: left;">Splitting require()
                            statements that use
                            &amp;&amp; saves gas</td>
                        <td style="text-align: center;">36</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#GAS-17">GAS-17</a></td>
                        <td style="text-align: left;">Use != 0 instead of &gt; 0
                            for unsigned
                            integer comparison</td>
                        <td style="text-align: center;">134</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#GAS-18">GAS-18</a></td>
                        <td style="text-align: left;"><code>internal</code>
                            functions not called
                            by the contract should be removed</td>
                        <td style="text-align: center;">18</td>
                    </tr>
                </tbody>
            </table>
            <h3
                id="gas-1-use-selfbalance-instead-of-addressthisbalance"><a
                    name="GAS-1"></a>[GAS-1]
                Use <code>selfbalance()</code> instead of
                <code>address(this).balance</code></h3>
            <p>Use assembly when getting a contract's balance of ETH.</p>
            <p>You can use <code>selfbalance()</code> instead of
                <code>address(this).balance</code> when getting your contract's
                balance
                of ETH to save gas. Additionally, you can use
                <code>balance(address)</code> instead of <code>address.balance()</code>
                when getting an external contract's balance of ETH.</p>
            <p><em>Saves 15 gas when checking internal balance, 6 for
                    external</em></p>
            <p><em>Instances (4)</em>:</p>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

324:         require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);

385:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

183:         require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);

244:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);
</code></pre>
            <h3
                id="gas-2-use-assembly-to-check-for-address0"><a name="GAS-2"></a>[GAS-2]
                Use assembly to check for <code>address(0)</code></h3>
            <p><em>Saves 6 gas per instance</em></p>
            <p><em>Instances (25)</em>:</p>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

232:         require(newOwner != address(0),&quot;Zero address not allowed&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

345:         if (account != address(0)) {
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

623:         require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);

624:         require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);

643:         require(account != address(0), &quot;ERC20: mint to the zero address&quot;);

664:         require(account != address(0), &quot;ERC20: burn from the zero address&quot;);

687:         require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);

688:         require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);

786:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

909:         require(signatory != address(0), &quot;SOY::delegateBySig: invalid signature&quot;);

988:             if (srcRep != address(0)) {

996:             if (dstRep != address(0)) {
</code></pre>
            <pre class="solidity"><code>File: Ownable.sol

74:         require(newOwner != address(0),&quot;Zero address not allowed&quot;);
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

490:         require(sender != address(0), &quot;ERC223: transfer from the zero address&quot;);

491:         require(recipient != address(0), &quot;ERC223: transfer to the zero address&quot;);

507:         require(sender != address(0), &quot;ERC223: transfer from the zero address&quot;);

508:         require(recipient != address(0), &quot;ERC223: transfer to the zero address&quot;);

527:         require(account != address(0), &quot;ERC20: mint to the zero address&quot;);

548:         require(account != address(0), &quot;ERC20: burn from the zero address&quot;);

571:         require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);

572:         require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);

660:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

810:         require(signatory != address(0), &quot;SOY::delegateBySig: invalid signature&quot;);

889:             if (srcRep != address(0)) {

897:             if (dstRep != address(0)) {
</code></pre>
            <h3
                id="gas-3-arrayindex--amount-is-cheaper-than-arrayindex--arrayindex--amount-or-related-variants"><a
                    name="GAS-3"></a>[GAS-3]
                <code>array[index] += amount</code> is cheaper than
                <code>array[index] = array[index] + amount</code> (or related
                variants)</h3>
            <p>When updating a value in an array with arithmetic, using
                <code>array[index] += amount</code> is cheaper than
                <code>array[index] = array[index] + amount</code>. This is
                because you
                avoid an additonal <code>mload</code> when the array is stored
                in
                memory, and an <code>sload</code> when the array is stored in
                storage.
                This can be applied for any arithmetic operation including
                <code>+=</code>,
                <code>-=</code>,<code>/=</code>,<code>*=</code>,<code>^=</code>,<code>&amp;=</code>,
                <code>%=</code>, <code>&lt;&lt;=</code>,<code>&gt;&gt;=</code>,
                and
                <code>&gt;&gt;&gt;=</code>. This optimization can be
                particularly
                significant if the pattern occurs during a loop.</p>
            <p><em>Saves 28 gas for a storage array, 38 for a memory array</em></p>
            <p><em>Instances (4)</em>:</p>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

495:         _balances[sender] = _balances[sender] - amount;

496:         _balances[recipient] = _balances[recipient] + amount;

512:         _balances[sender] = _balances[sender] - amount;

513:         _balances[recipient] = _balances[recipient] + amount;
</code></pre>
            <h3
                id="gas-4-using-bools-for-storage-incurs-overhead"><a
                    name="GAS-4"></a>[GAS-4]
                Using bools for storage incurs overhead</h3>
            <p>Use uint256(1) and uint256(2) for true/false to avoid a
                Gwarmaccess
                (100 gas), and to avoid Gsset (20000 gas) when changing from
                ‘false’ to
                ‘true’, after having been ‘true’ in the past. See <a
                    href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27">source</a>.</p>
            <p><em>Instances (12)</em>:</p>
            <pre class="solidity"><code>File: Farming/Initializable.sol

36:     bool private _initialized;

41:     bool private _initializing;
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

280:     bool public active = false;
</code></pre>
            <pre class="solidity"><code>File: IDO/ido.sol

215:     mapping(address =&gt; bool) public allowedToken;   // token accepted for payment

216:     bool public isPaused;
</code></pre>
            <pre class="solidity"><code>File: Old/CLOE_ERC20.sol

337:   mapping(address =&gt; bool) public gateways; // different gateways will be used for different pairs (chains)
</code></pre>
            <pre class="solidity"><code>File: Old/SOY_ERC20.sol

337:   mapping(address =&gt; bool) public gateways; // different gateways will be used for different pairs (chains)
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

38:     bool public setup_mode = true;

39:     mapping (address =&gt; bool) public minters;
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

125:     bool public isEnabled;
</code></pre>
            <pre class="solidity"><code>File: Vesting.sol

152:     mapping(address =&gt; bool) public depositors; // address of users who has right to deposit and allocate tokens
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

15:     mapping (address =&gt; mapping(address =&gt; bool)) public isReceived; // token =&gt; user =&gt; isReceived
</code></pre>
            <h3
                id="gas-5-cache-array-length-outside-of-loop"><a name="GAS-5"></a>[GAS-5]
                Cache array length outside of loop</h3>
            <p>If not cached, the solidity compiler will always read the length
                of
                the array during each iteration. That is, if it is a storage
                array, this
                is an extra sload operation (100 additional extra gas for each
                iteration
                except for the first) and if it is a memory array, this is an
                extra
                mload operation (3 additional gas for each iteration except for
                the
                first).</p>
            <p><em>Instances (24)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

251:         for (uint i = 0; i &lt; users.length; i++) {

266:         for (uint i = 0; i &lt; users.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: IDO/priceFeed.sol

100:         for (uint i=0; i&lt;token.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

811:         for (uint256 i = 0; i &lt; _ticketNumbers.length; i++) {

854:         for (uint256 i = 0; i &lt; _ticketIds.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

812:         for (uint256 i = 0; i &lt; _ticketNumbers.length; i++) {

856:         for (uint256 i = 0; i &lt; _ticketIds.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Muticall2.sol

22:         for(uint256 i = 0; i &lt; calls.length; i++) {

57:         for(uint256 i = 0; i &lt; calls.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

342:         for (uint i; i &lt; path.length - 1; i++) {

353:         for (uint i = path.length - 1; i &gt; 0; i--) {

603:         for (uint i; i &lt; path.length - 1; i++) {

712:         for (uint i; i &lt; path.length - 1; i++) {

739:         uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);

762:         uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

307:         for (uint i; i &lt; path.length - 1; i++) {

318:         for (uint i = path.length - 1; i &gt; 0; i--) {

600:         for (uint i; i &lt; path.length - 1; i++) {

712:         for (uint i; i &lt; path.length - 1; i++) {

740:         uint balanceBefore = IERC223(path[path.length - 1]).balanceOf(to);

767:         uint balanceBefore = IERC223(path[path.length - 1]).balanceOf(to);
</code></pre>
            <pre class="solidity"><code>File: Vesting.sol

249:         for (uint256 i = 0; i &lt; beneficiaries[beneficiary].length; i++) {
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

42:         for (uint i = 0; i &lt; recipients.length; i++) {

50:         for (uint i = 0; i &lt; recipients.length; i++) {
</code></pre>
            <h3
                id="gas-6-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage"><a
                    name="GAS-6"></a>[GAS-6]
                State variables should be cached in stack variables rather than
                re-reading them from storage</h3>
            <p>The instances below point to the second+ access of a state
                variable
                within a function. Caching of a state variable replaces each
                Gwarmaccess
                (100 gas) with a much cheaper stack read. Other less obvious
                fixes/optimizations include having local memory caches of state
                variable
                structs, or having local caches of state variable
                contracts/addresses.</p>
            <p><em>Saves 100 gas per instance</em></p>
            <p><em>Instances (3)</em>:</p>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

341:             _accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

315:             rewardRate        = (reward + leftover) / rewardsDuration;
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

318:         uint _StakingRewardPool = IERC223(SOY).balanceOf(address(this)).sub(TotalStakingAmount);
</code></pre>
            <h3
                id="gas-7-use-calldata-instead-of-memory-for-function-arguments-that-do-not-get-mutated"><a
                    name="GAS-7"></a>[GAS-7]
                Use calldata instead of memory for function arguments that do
                not get
                mutated</h3>
            <p>Mark data types as <code>calldata</code> instead of
                <code>memory</code> where possible. This makes it so that the
                data is
                not automatically loaded into memory. If the data passed into
                the
                function does not need to be changed (like updating values in an
                array),
                it can be passed in as <code>calldata</code>. The one exception
                to this
                is if the argument must later be passed into another function
                that takes
                an argument that specifies <code>memory</code> storage.</p>
            <p><em>Instances (10)</em>:</p>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

48:     function transfer(address to, uint value, bytes memory data) public virtual returns (bool success);

295:     function tokenReceived(address _from, uint256 _amount, bytes memory _data) public override nonReentrant onlyActive
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

51:     function transfer(address to, uint value, bytes memory data) public virtual returns (bool success);

209:     function tokenReceived(address _from, uint256 _amount, bytes memory _data) public override
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

470:     constructor (string memory name, string memory symbol) public {

470:     constructor (string memory name, string memory symbol) public {
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

13:     function tokenReceived(address _from, uint _value, bytes memory _data) external virtual;

318:     constructor (string memory new_name, string memory new_symbol) {

318:     constructor (string memory new_name, string memory new_symbol) {
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

61:     function transfer(address to, uint value, bytes memory data) external returns (bool success);
</code></pre>
            <h3
                id="gas-8-for-operations-that-will-not-overflow-you-could-use-unchecked"><a
                    name="GAS-8"></a>[GAS-8]
                For Operations that will not overflow, you could use unchecked</h3>
            <p><em>Instances (2114)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

159:         uint256 duration;   // in days

159:         uint256 duration;   // in days

173:     IERC223 public token;   // token to airdrop

173:     IERC223 public token;   // token to airdrop

174:     uint256 constant public lockPeriod = 180;  // 180 days (6 months) lock period

174:     uint256 constant public lockPeriod = 180;  // 180 days (6 months) lock period

175:     mapping(uint256 =&gt; mapping(address =&gt; User)) public receivers; // airdrop ID =&gt; user address =&gt; amount and timestamp

175:     mapping(uint256 =&gt; mapping(address =&gt; User)) public receivers; // airdrop ID =&gt; user address =&gt; amount and timestamp

176:     mapping(uint256 =&gt; mapping(uint256 =&gt; Participants)) public participants; // airdrop ID =&gt; day =&gt; Participants

176:     mapping(uint256 =&gt; mapping(uint256 =&gt; Participants)) public participants; // airdrop ID =&gt; day =&gt; Participants

215:         for (uint i = 0; i &lt; len; i++) {

215:         for (uint i = 0; i &lt; len; i++) {

241:         require(airdrops[airdropId].daysPassed + 1 == day, &quot;Day already passed&quot;);

243:         uint256 timestamp = block.timestamp / 1 days * 1 days;  // align timestamp to 00:00 UTC

243:         uint256 timestamp = block.timestamp / 1 days * 1 days;  // align timestamp to 00:00 UTC

243:         uint256 timestamp = block.timestamp / 1 days * 1 days;  // align timestamp to 00:00 UTC

243:         uint256 timestamp = block.timestamp / 1 days * 1 days;  // align timestamp to 00:00 UTC

245:         uint256 amount = airdrops[airdropId].amount / (airdrops[airdropId].duration * totalParticipants);

245:         uint256 amount = airdrops[airdropId].amount / (airdrops[airdropId].duration * totalParticipants);

246:         participants[airdropId][day].addedParticipants += users.length;

249:             airdrops[airdropId].daysPassed = airdrops[airdropId].daysPassed + 1;

251:         for (uint i = 0; i &lt; users.length; i++) {

251:         for (uint i = 0; i &lt; users.length; i++) {

266:         for (uint i = 0; i &lt; users.length; i++) {

266:         for (uint i = 0; i &lt; users.length; i++) {

268:             if (u.timestamp + lockPeriod &lt;= block.timestamp &amp;&amp; u.amount &gt; 0)  {
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYGlobalFarmSimplified.sol

91:         address _rewardsToken,      // SOY token

91:         address _rewardsToken,      // SOY token

92:         address _lpToken            // LP token that will be staked in this Local Farm

92:         address _lpToken            // LP token that will be staked in this Local Farm

104:     IMintableToken public rewardsToken;                 // SOY token

104:     IMintableToken public rewardsToken;                 // SOY token

105:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

105:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

105:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

105:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

105:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

105:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

105:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

105:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

106:     uint256 public thisChainMultiplier;                 // multiplier in Callisto Global Farming for this chain

106:     uint256 public thisChainMultiplier;                 // multiplier in Callisto Global Farming for this chain

107:     uint256 public cloTotalMultipliers;                 // totalMultipliers on CLO side

107:     uint256 public cloTotalMultipliers;                 // totalMultipliers on CLO side

109:     uint256 public paymentDelay = 1 days;          // DEFAULTS_TO 1 days

109:     uint256 public paymentDelay = 1 days;          // DEFAULTS_TO 1 days

113:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1

113:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1

115:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

115:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

115:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

116:     mapping(address =&gt; uint256)   public nextMint; // timestamp when token may be minted to local farm

116:     mapping(address =&gt; uint256)   public nextMint; // timestamp when token may be minted to local farm

133:         return (block.timestamp / paymentDelay) * paymentDelay + paymentDelay;

133:         return (block.timestamp / paymentDelay) * paymentDelay + paymentDelay;

133:         return (block.timestamp / paymentDelay) * paymentDelay + paymentDelay;

138:         return localFarms[localFarmId[_farm]].lastPayment + paymentDelay &lt; next_payment();

143:         return 1000 * localFarms[localFarmId[_farm]].multiplier / totalMultipliers;

143:         return 1000 * localFarms[localFarmId[_farm]].multiplier / totalMultipliers;

149:         return (tokensPerYear * thisChainMultiplier) / (365 days * cloTotalMultipliers);

149:         return (tokensPerYear * thisChainMultiplier) / (365 days * cloTotalMultipliers);

149:         return (tokensPerYear * thisChainMultiplier) / (365 days * cloTotalMultipliers);

161:         address _lpToken,            // LP token that will be staked in this Local Farm

161:         address _lpToken,            // LP token that will be staked in this Local Farm

170:         lastAddedFarmIndex++;

170:         lastAddedFarmIndex++;

174:         localFarms[lastAddedFarmIndex].lastPayment = next_payment() - paymentDelay;

178:         totalMultipliers += uint256(_multiplier);

192:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

192:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

192:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

197:         localFarms[localFarmId[_localFarmAddress]].multiplier   = 0; // Not critically important, can be removed for gas efficiency reasons.

197:         localFarms[localFarmId[_localFarmAddress]].multiplier   = 0; // Not critically important, can be removed for gas efficiency reasons.

198:         localFarms[localFarmId[_localFarmAddress]].lastPayment  = 0; // Not critically important, can be removed for gas efficiency reasons.

198:         localFarms[localFarmId[_localFarmAddress]].lastPayment  = 0; // Not critically important, can be removed for gas efficiency reasons.

210:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

210:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

210:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

210:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

240:         if(localFarms[localFarmId[_localFarmAddress]].lastPayment + paymentDelay &gt; next_payment())

248:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;

248:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;

248:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;

248:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYLocalFarm.sol

44:         _guardCounter += 1;

88:         uint256 amount;     // How many LP tokens the user has provided.

88:         uint256 amount;     // How many LP tokens the user has provided.

89:         uint256 rewardDebt; // Reward debt. See explanation below.

89:         uint256 rewardDebt; // Reward debt. See explanation below.

94:     uint256 public limitAmount; // Prevents accumulatedRewardPerShare from overflowing.

94:     uint256 public limitAmount; // Prevents accumulatedRewardPerShare from overflowing.

99:     uint256 public lastRewardTimestamp;  // Last block number that SOY distribution occurs.

99:     uint256 public lastRewardTimestamp;  // Last block number that SOY distribution occurs.

100:     uint256 public accumulatedRewardPerShare; // Accumulated SOY per share, times 1e18. See below.

100:     uint256 public accumulatedRewardPerShare; // Accumulated SOY per share, times 1e18. See below.

116:         address _rewardsToken,      // SOY token

116:         address _rewardsToken,      // SOY token

117:         address _lpToken            // LP token that will be staked in this Local Farm

117:         address _lpToken            // LP token that will be staked in this Local Farm

124:         globalFarm          = msg.sender; // GlobalFarm contract

124:         globalFarm          = msg.sender; // GlobalFarm contract

146:         require(userInfo[_from].amount + _amount &lt;= limitAmount, &#39;exceed the top&#39;);

150:             uint256 pending = userInfo[_from].amount * accumulatedRewardPerShare / 1e18 - userInfo[_from].rewardDebt;

150:             uint256 pending = userInfo[_from].amount * accumulatedRewardPerShare / 1e18 - userInfo[_from].rewardDebt;

150:             uint256 pending = userInfo[_from].amount * accumulatedRewardPerShare / 1e18 - userInfo[_from].rewardDebt;

156:             userInfo[_from].amount += _amount;

158:         userInfo[_from].rewardDebt = userInfo[_from].amount * accumulatedRewardPerShare / 1e18;

158:         userInfo[_from].rewardDebt = userInfo[_from].amount * accumulatedRewardPerShare / 1e18;

186:             uint256 multiplier = block.timestamp - lastRewardTimestamp;

187:             uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

187:             uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

187:             uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

188:             _accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

188:             _accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

188:             _accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

190:         return user.amount * _accumulatedRewardPerShare / 1e18 - user.rewardDebt;

190:         return user.amount * _accumulatedRewardPerShare / 1e18 - user.rewardDebt;

190:         return user.amount * _accumulatedRewardPerShare / 1e18 - user.rewardDebt;

206:         uint256 multiplier = block.timestamp - lastRewardTimestamp;

213:         uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

213:         uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

213:         uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

214:         accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

214:         accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

214:         accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

226:         uint256 pending = user.amount * accumulatedRewardPerShare / 1e18 - user.rewardDebt;

226:         uint256 pending = user.amount * accumulatedRewardPerShare / 1e18 - user.rewardDebt;

226:         uint256 pending = user.amount * accumulatedRewardPerShare / 1e18 - user.rewardDebt;

231:             user.amount = user.amount - _amount;

234:         user.rewardDebt = user.amount * accumulatedRewardPerShare / 1e18;

234:         user.rewardDebt = user.amount * accumulatedRewardPerShare / 1e18;
</code></pre>
            <pre class="solidity"><code>File: BTTC/WBTT.sol

67:         balanceOf[msg.sender] += msg.value;

71:         balanceOf[msg.sender] -= wad;

110:         if (src != msg.sender &amp;&amp; allowance[src][msg.sender] != uint(int(-1))) {

111:             allowance[src][msg.sender] -= wad;

114:         balanceOf[src] -= wad;

115:         balanceOf[dst] += wad;

122:     function tokenReceived(address _from, uint _value, bytes memory /*_data*/) external {

122:     function tokenReceived(address _from, uint _value, bytes memory /*_data*/) external {

122:     function tokenReceived(address _from, uint _value, bytes memory /*_data*/) external {

122:     function tokenReceived(address _from, uint _value, bytes memory /*_data*/) external {

125:         balanceOf[_from] -= _value;

136:  Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;

136:  Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;

136:  Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;

148: share and change all versions of a program--to make sure it remains free

148: share and change all versions of a program--to make sure it remains free

174: giving you legal permission to copy, distribute and/or modify it.

195: software on general-purpose computers, but in those that do, we wish to

198: patents cannot be used to render the program non-free.

209:   &quot;Copyright&quot; also means copyright-like laws that apply to other kinds of

247: for making modifications to it.  &quot;Object code&quot; means any non-source

270: System Libraries, or general-purpose tools or generally available free

311:   3. Protecting Users&#39; Legal Rights From Anti-Circumvention Law.

333: non-permissive terms added in accord with section 7 apply to the code;

377:   6. Conveying Non-Source Forms.

381: machine-readable Corresponding Source under the terms of this License,

420:     e) Convey the object code using peer-to-peer transmission, provided

420:     e) Convey the object code using peer-to-peer transmission, provided

439: commercial, industrial or non-consumer uses, unless such uses represent

520:   All other non-permissive additional terms are considered &quot;further

535:   Additional terms, permissive or non-permissive, may be stated in the

571: occurring solely as a consequence of using peer-to-peer transmission

571: occurring solely as a consequence of using peer-to-peer transmission

599: (including a cross-claim or counterclaim in a lawsuit) alleging that

619:   Each contributor grants you a non-exclusive, worldwide, royalty-free

619:   Each contributor grants you a non-exclusive, worldwide, royalty-free

655: conditioned on the non-exercise of one or more of the rights that are

697:   The Free Software Foundation may publish revised and/or new versions of

725: HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY

735: WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS

769:     This program is free software: you can redistribute it and/or modify

780:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

780:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

780:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

780:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

799: &lt;http://www.gnu.org/licenses/&gt;.

799: &lt;http://www.gnu.org/licenses/&gt;.

799: &lt;http://www.gnu.org/licenses/&gt;.

799: &lt;http://www.gnu.org/licenses/&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.
</code></pre>
            <pre class="solidity"><code>File: Farming/LocalToBridge.sol

6:         address receiver,   // address of token receiver on destination chain

6:         address receiver,   // address of token receiver on destination chain

7:         address token,      // token that user send (if token address &lt; 32, then send native coin)

7:         address token,      // token that user send (if token address &lt; 32, then send native coin)

8:         uint256 value,      // tokens value

8:         uint256 value,      // tokens value

9:         uint256 toChainId   // destination chain Id where will be claimed tokens

9:         uint256 toChainId   // destination chain Id where will be claimed tokens

37:     uint256 public lastRewardTimestamp;  // Last block number that SOY distribution occurs.

37:     uint256 public lastRewardTimestamp;  // Last block number that SOY distribution occurs.
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarm.sol

30:         return (a &amp; b) + (a ^ b) / 2;

30:         return (a &amp; b) + (a ^ b) / 2;

41:         return a / b + (a % b == 0 ? 0 : 1);

41:         return a / b + (a % b == 0 ? 0 : 1);

59:         uint256 _value; // default: 0

59:         uint256 _value; // default: 0

68:             counter._value += 1;

76:             counter._value = value - 1;

114:                 low = mid + 1;

119:         if (low &gt; 0 &amp;&amp; array[low - 1] == element) {

120:             return low - 1;

236:     IMintableToken public rewardsToken;                 // SOY token

236:     IMintableToken public rewardsToken;                 // SOY token

237:     uint256 public tokensPerYear  = 50 * 10**6 * 10*18;  // 50M tokens

237:     uint256 public tokensPerYear  = 50 * 10**6 * 10*18;  // 50M tokens

237:     uint256 public tokensPerYear  = 50 * 10**6 * 10*18;  // 50M tokens

237:     uint256 public tokensPerYear  = 50 * 10**6 * 10*18;  // 50M tokens

237:     uint256 public tokensPerYear  = 50 * 10**6 * 10*18;  // 50M tokens

237:     uint256 public tokensPerYear  = 50 * 10**6 * 10*18;  // 50M tokens

237:     uint256 public tokensPerYear  = 50 * 10**6 * 10*18;  // 50M tokens

241:     uint256 public activeSnapshotId = 1;  // Contract operates by two types of snapshots

241:     uint256 public activeSnapshotId = 1;  // Contract operates by two types of snapshots

249:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1

249:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1

251:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

251:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

251:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

252:     mapping(address =&gt; uint256)   public nextMint; // timestamp when token may be minted to local farm

252:     mapping(address =&gt; uint256)   public nextMint; // timestamp when token may be minted to local farm

270:             activeSnapshotId++;

270:             activeSnapshotId++;

377:             return ids[ids.length - 1];

390:         return (block.timestamp / 1 days) * 1 days;

390:         return (block.timestamp / 1 days) * 1 days;

395:         return ( (block.timestamp / 1 days) * 1 days) + 1 days;

395:         return ( (block.timestamp / 1 days) * 1 days) + 1 days;

395:         return ( (block.timestamp / 1 days) * 1 days) + 1 days;

411:         _updateTotalMultipliersSnapshot(totalMultipliers + _multiplier);

415:         lastAddedFarmIndex++;

415:         lastAddedFarmIndex++;

425:         totalMultipliers += uint256(_multiplier);

434:         require(_id != 0,  &quot;LocalFarm at address 0 is considered non-existing by system&quot;);

438:         _updateTotalMultipliersSnapshot(totalMultipliers + _multiplier);

444:         totalMultipliers += uint256(_multiplier);

459:         _updateTotalMultipliersSnapshot(totalMultipliers - localFarms[localFarmId[_localFarmAddress]].multiplier);

461:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

461:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

461:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

466:         localFarms[localFarmId[_localFarmAddress]].multiplier         = 0; // Not critically important, can be removed for gas efficiency reasons.

466:         localFarms[localFarmId[_localFarmAddress]].multiplier         = 0; // Not critically important, can be removed for gas efficiency reasons.

467:         localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp  = 0; // Not critically important, can be removed for gas efficiency reasons.

467:         localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp  = 0; // Not critically important, can be removed for gas efficiency reasons.

479:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

479:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

479:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

479:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

511:         if(localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp + rewardDuration &lt; block.timestamp)

515:             if(_period &lt; block.timestamp - localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp)

527:                 localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp += _period;

534:                 _period = block.timestamp - localFarms[localFarmId[_localFarmAddress]].lastMintTimestamp;

540:             uint256 amount = tokensPerYear * _period / 365 days; // for all farms

540:             uint256 amount = tokensPerYear * _period / 365 days; // for all farms

540:             uint256 amount = tokensPerYear * _period / 365 days; // for all farms

540:             uint256 amount = tokensPerYear * _period / 365 days; // for all farms

541:             amount = amount * localFarms[localFarmId[_localFarmAddress]].multiplier / totalMultipliers; // amount per local farm

541:             amount = amount * localFarms[localFarmId[_localFarmAddress]].multiplier / totalMultipliers; // amount per local farm

541:             amount = amount * localFarms[localFarmId[_localFarmAddress]].multiplier / totalMultipliers; // amount per local farm

541:             amount = amount * localFarms[localFarmId[_localFarmAddress]].multiplier / totalMultipliers; // amount per local farm
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarmSimplified.sol

96:     IMintableToken public rewardsToken;                 // SOY token

96:     IMintableToken public rewardsToken;                 // SOY token

97:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

97:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

97:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

97:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

97:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

97:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

97:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

97:     uint256 public tokensPerYear = 50 * 10**6 * 10**18; // 50M tokens

99:     uint256 public paymentDelay = 1 days;          // DEFAULTS_TO 1 days

99:     uint256 public paymentDelay = 1 days;          // DEFAULTS_TO 1 days

103:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1

103:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1

105:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

105:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

105:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

106:     mapping(address =&gt; uint256)   public nextMint; // timestamp when token may be minted to local farm

106:     mapping(address =&gt; uint256)   public nextMint; // timestamp when token may be minted to local farm

120:         return (block.timestamp / paymentDelay) * paymentDelay + paymentDelay;

120:         return (block.timestamp / paymentDelay) * paymentDelay + paymentDelay;

120:         return (block.timestamp / paymentDelay) * paymentDelay + paymentDelay;

125:         return localFarms[localFarmId[_farm]].lastPayment + paymentDelay &lt; next_payment();

130:         return 1000 * localFarms[localFarmId[_farm]].multiplier / totalMultipliers;

130:         return 1000 * localFarms[localFarmId[_farm]].multiplier / totalMultipliers;

136:         return tokensPerYear / 365 days;

152:         lastAddedFarmIndex++;

152:         lastAddedFarmIndex++;

156:         localFarms[lastAddedFarmIndex].lastPayment = next_payment() - paymentDelay;

160:         totalMultipliers += uint256(_multiplier);

168:         require(_id != 0,  &quot;LocalFarm at address 0 is considered non-existing by system&quot;);

179:         totalMultipliers += uint256(_multiplier);

193:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

193:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

193:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

198:         localFarms[localFarmId[_localFarmAddress]].multiplier   = 0; // Not critically important, can be removed for gas efficiency reasons.

198:         localFarms[localFarmId[_localFarmAddress]].multiplier   = 0; // Not critically important, can be removed for gas efficiency reasons.

199:         localFarms[localFarmId[_localFarmAddress]].lastPayment  = 0; // Not critically important, can be removed for gas efficiency reasons.

199:         localFarms[localFarmId[_localFarmAddress]].lastPayment  = 0; // Not critically important, can be removed for gas efficiency reasons.

211:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

211:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

211:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

211:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

227:         if(localFarms[localFarmId[_localFarmAddress]].lastPayment + paymentDelay &gt; next_payment())

235:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;

235:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;

235:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;

235:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

28:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

28:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

28:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

28:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

28:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

28:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

134:         _guardCounter += 1;

253:         uint256 amount;     // How many LP tokens the user has provided.

253:         uint256 amount;     // How many LP tokens the user has provided.

254:         uint256 rewardDebt; // Reward debt. See explanation below.

254:         uint256 rewardDebt; // Reward debt. See explanation below.

259:     uint256 public limitAmount = 1e40; // Prevents accumulatedRewardPerShare from overflowing.

259:     uint256 public limitAmount = 1e40; // Prevents accumulatedRewardPerShare from overflowing.

264:     uint256 public lastRewardTimestamp;  // Last block number that SOY distribution occurs.

264:     uint256 public lastRewardTimestamp;  // Last block number that SOY distribution occurs.

265:     uint256 public accumulatedRewardPerShare; // Accumulated SOY per share, times 1e18. See below.

265:     uint256 public accumulatedRewardPerShare; // Accumulated SOY per share, times 1e18. See below.

270:         address _rewardsDistribution,   // GlobalFarm contract

270:         address _rewardsDistribution,   // GlobalFarm contract

271:         address _rewardsToken,          // SOY token

271:         address _rewardsToken,          // SOY token

272:         address _lpToken           // LP token that will be staked in this Local Farm

272:         address _lpToken           // LP token that will be staked in this Local Farm

298:         require(userInfo[_from].amount + _amount &lt;= limitAmount, &#39;exceed the top&#39;);

302:             uint256 pending = userInfo[_from].amount * accumulatedRewardPerShare / 1e18 - userInfo[_from].rewardDebt;

302:             uint256 pending = userInfo[_from].amount * accumulatedRewardPerShare / 1e18 - userInfo[_from].rewardDebt;

302:             uint256 pending = userInfo[_from].amount * accumulatedRewardPerShare / 1e18 - userInfo[_from].rewardDebt;

308:             userInfo[_from].amount += _amount;

310:         userInfo[_from].rewardDebt = userInfo[_from].amount * accumulatedRewardPerShare / 1e18;

310:         userInfo[_from].rewardDebt = userInfo[_from].amount * accumulatedRewardPerShare / 1e18;

339:             uint256 multiplier = block.timestamp - lastRewardTimestamp;

340:             uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

340:             uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

340:             uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

341:             _accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

341:             _accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

341:             _accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

343:         return user.amount * _accumulatedRewardPerShare / 1e18 - user.rewardDebt;

343:         return user.amount * _accumulatedRewardPerShare / 1e18 - user.rewardDebt;

343:         return user.amount * _accumulatedRewardPerShare / 1e18 - user.rewardDebt;

359:         uint256 multiplier = block.timestamp - lastRewardTimestamp;

366:         uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

366:         uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

366:         uint256 _reward = multiplier * getRewardPerSecond() * getAllocationX1000() / 1000;

367:         accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

367:         accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

367:         accumulatedRewardPerShare = accumulatedRewardPerShare + (_reward * 1e18 / lpSupply);

379:         uint256 pending = user.amount * accumulatedRewardPerShare / 1e18 - user.rewardDebt;

379:         uint256 pending = user.amount * accumulatedRewardPerShare / 1e18 - user.rewardDebt;

379:         uint256 pending = user.amount * accumulatedRewardPerShare / 1e18 - user.rewardDebt;

384:             user.amount = user.amount - _amount;

387:         user.rewardDebt = user.amount * accumulatedRewardPerShare / 1e18;

387:         user.rewardDebt = user.amount * accumulatedRewardPerShare / 1e18;
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

137:         _guardCounter += 1;

197:         address _rewardsDistribution,   // GlobalFarm contract

197:         address _rewardsDistribution,   // GlobalFarm contract

198:         address _rewardsToken,          // SOY token

198:         address _rewardsToken,          // SOY token

199:         address _stakingToken           // LP token that will be staked in this Local Farm

199:         address _stakingToken           // LP token that will be staked in this Local Farm

211:         _data; // Stupid warning silencer.

211:         _data; // Stupid warning silencer.

216:         _totalFarmingSupply += _amount;

217:         _balances[_from]    += _amount;

226:         _totalFarmingSupply = _totalFarmingSupply + amount;

227:         _balances[msg.sender] = _balances[msg.sender] + amount;

240:         _totalFarmingSupply = _totalFarmingSupply + amount;

241:         _balances[msg.sender] = _balances[msg.sender] + amount;

265:         return rewardPerTokenStored + (lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18 / _totalFarmingSupply;

265:         return rewardPerTokenStored + (lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18 / _totalFarmingSupply;

265:         return rewardPerTokenStored + (lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18 / _totalFarmingSupply;

265:         return rewardPerTokenStored + (lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18 / _totalFarmingSupply;

265:         return rewardPerTokenStored + (lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18 / _totalFarmingSupply;

269:         return _balances[account] * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18 + rewards[account];

269:         return _balances[account] * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18 + rewards[account];

269:         return _balances[account] * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18 + rewards[account];

269:         return _balances[account] * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18 + rewards[account];

273:         return rewardRate * rewardsDuration;

282:         _totalFarmingSupply   -= amount;

283:         _balances[msg.sender] -= amount;

310:             rewardRate = reward / rewardsDuration;

313:             uint256 remaining = periodFinish - block.timestamp;

314:             uint256 leftover  = remaining * rewardRate;

315:             rewardRate        = (reward + leftover) / rewardsDuration;

315:             rewardRate        = (reward + leftover) / rewardsDuration;

323:         require(rewardRate &lt;= balance / rewardsDuration, &quot;Provided reward is too high&quot;);

326:             lastUpdateTime = block.timestamp;  // for first time

326:             lastUpdateTime = block.timestamp;  // for first time

328:             uint256 startNewPeriod = block.timestamp / rewardsDuration;

332:         periodFinish = (block.timestamp / rewardsDuration) * rewardsDuration;    // set periodFinish at 00:00 UTC

332:         periodFinish = (block.timestamp / rewardsDuration) * rewardsDuration;    // set periodFinish at 00:00 UTC

332:         periodFinish = (block.timestamp / rewardsDuration) * rewardsDuration;    // set periodFinish at 00:00 UTC

332:         periodFinish = (block.timestamp / rewardsDuration) * rewardsDuration;    // set periodFinish at 00:00 UTC
</code></pre>
            <pre class="solidity"><code>File: IDO/UpgradeableProxyFlattened.sol

163:       return functionCall(target, data, &quot;Address: low-level call failed&quot;);

188:         return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);

199:         require(isContract(target), &quot;Address: call to non-contract&quot;);

213:         return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);

223:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

269:         assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(&quot;eip1967.proxy.implementation&quot;)) - 1));

356:         assert(_ADMIN_SLOT == bytes32(uint256(keccak256(&quot;eip1967.proxy.admin&quot;)) - 1));
</code></pre>
            <pre class="solidity"><code>File: IDO/ido.sol

198:         uint256 soyToSell;  // amount of SOY sell in this round

198:         uint256 soyToSell;  // amount of SOY sell in this round

199:         uint256 usdCollected;   // USD value received in this round

199:         uint256 usdCollected;   // USD value received in this round

200:         uint256 hardCap;    // maximum amount of USD that can be collected by this round

200:         uint256 hardCap;    // maximum amount of USD that can be collected by this round

201:         uint256 softCap;    // minimum amount of USD to collect

201:         uint256 softCap;    // minimum amount of USD to collect

202:         uint256 start;  // timestamp when auction start

202:         uint256 start;  // timestamp when auction start

203:         uint256 end;    // timestamp when auction end

203:         uint256 end;    // timestamp when auction end

207:         uint256 usdValue;       // contributed usd in this round

207:         uint256 usdValue;       // contributed usd in this round

208:         uint256 soyAmount;      // amount locked SOY

208:         uint256 soyAmount;      // amount locked SOY

209:         uint256 lockedUntil;    // locked until

209:         uint256 lockedUntil;    // locked until

213:     mapping(uint256 =&gt; mapping(address =&gt; Bet)) public bets;    // round ID =&gt; user address =&gt; Bet

213:     mapping(uint256 =&gt; mapping(address =&gt; Bet)) public bets;    // round ID =&gt; user address =&gt; Bet

214:     mapping(uint256 =&gt; Round) public auctionRound; // round ID =&gt; Round

214:     mapping(uint256 =&gt; Round) public auctionRound; // round ID =&gt; Round

215:     mapping(address =&gt; bool) public allowedToken;   // token accepted for payment

215:     mapping(address =&gt; bool) public allowedToken;   // token accepted for payment

218:     uint256 constant public RATIO = 1017233603000000000; // 1.017233603

218:     uint256 constant public RATIO = 1017233603000000000; // 1.017233603

219:     address constant public priceFeed = address(0x9bFc3046ea26f8B09D3E85bd22AEc96C80D957e3);   // price feed contract

219:     address constant public priceFeed = address(0x9bFc3046ea26f8B09D3E85bd22AEc96C80D957e3);   // price feed contract

220:     address payable public bank;    // receiver of bets tokens

220:     address payable public bank;    // receiver of bets tokens

221:     uint256 public totalSoyToSell;  // total amount of Soy to sell

221:     uint256 public totalSoyToSell;  // total amount of Soy to sell

222:     uint256 public totalSoySold;    // total amount of sold Soy including Soy in active auction.

222:     uint256 public totalSoySold;    // total amount of sold Soy including Soy in active auction.

223:     uint256 public auctionRounds;   // number of auction rounds

223:     uint256 public auctionRounds;   // number of auction rounds

224:     uint256 public currentRoundId;  // current auction round (round starts from 1)

224:     uint256 public currentRoundId;  // current auction round (round starts from 1)

228:     uint256 public roundDuration;  // auction round duration (in seconds).

228:     uint256 public roundDuration;  // auction round duration (in seconds).

229:     uint256 public lockPeriod;   // period while tokens will be locked

229:     uint256 public lockPeriod;   // period while tokens will be locked

230:     uint256 public lockPercentage;  // percentage of bought tokens that will be locked

230:     uint256 public lockPercentage;  // percentage of bought tokens that will be locked

231:     uint256 public minPricePercentage;  // percentage of previous auction price assign to min price

231:     uint256 public minPricePercentage;  // percentage of previous auction price assign to min price

232:     uint256 public maxPricePercentage;  // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

232:     uint256 public maxPricePercentage;  // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

232:     uint256 public maxPricePercentage;  // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

232:     uint256 public maxPricePercentage;  // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

233:     uint256 public lastRoundSoyPrice;       // previous auction price

233:     uint256 public lastRoundSoyPrice;       // previous auction price

234:     uint256 public maxExtendRounds;    // maximum number of rounds to extend tha auction

234:     uint256 public maxExtendRounds;    // maximum number of rounds to extend tha auction

253:         lockPeriod = 365 days;   // period while tokens will be locked

253:         lockPeriod = 365 days;   // period while tokens will be locked

254:         minPricePercentage = 90;  // percentage of previous auction price assign to min price

254:         minPricePercentage = 90;  // percentage of previous auction price assign to min price

255:         maxExtendRounds = 3;    // maximum number of rounds to extend the auction

255:         maxExtendRounds = 3;    // maximum number of rounds to extend the auction

258:         roundDuration = 7 days;  // auction round duration (in seconds).

258:         roundDuration = 7 days;  // auction round duration (in seconds).

259:         maxPricePercentage = 500; // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

259:         maxPricePercentage = 500; // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

259:         maxPricePercentage = 500; // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

259:         maxPricePercentage = 500; // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

260:         lockPercentage = 70;    // 50% of Soy will be locked

260:         lockPercentage = 70;    // 50% of Soy will be locked

261:         auctionRounds = 26;   // number of auction rounds

261:         auctionRounds = 26;   // number of auction rounds

264:         roundDuration = 1 days;  // auction round duration (in seconds).

264:         roundDuration = 1 days;  // auction round duration (in seconds).

265:         maxPricePercentage = 160; // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

265:         maxPricePercentage = 160; // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

265:         maxPricePercentage = 160; // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

265:         maxPricePercentage = 160; // maxPrice = lastRoundSoyPrice * maxPricePercentage / 100

266:         lockPercentage = 50;    // 50% of Soy will be locked

266:         lockPercentage = 50;    // 50% of Soy will be locked

267:         auctionRounds = 180;   // number of auction rounds

267:         auctionRounds = 180;   // number of auction rounds

322:         totalSoySold = totalSoySold + amount - currentAmount;

322:         totalSoySold = totalSoySold + amount - currentAmount;

325:         auctionRound[currentRoundId].hardCap = amount * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

325:         auctionRound[currentRoundId].hardCap = amount * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

325:         auctionRound[currentRoundId].hardCap = amount * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

325:         auctionRound[currentRoundId].hardCap = amount * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

325:         auctionRound[currentRoundId].hardCap = amount * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

325:         auctionRound[currentRoundId].hardCap = amount * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

325:         auctionRound[currentRoundId].hardCap = amount * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

325:         auctionRound[currentRoundId].hardCap = amount * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

325:         auctionRound[currentRoundId].hardCap = amount * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

325:         auctionRound[currentRoundId].hardCap = amount * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

326:         auctionRound[currentRoundId].softCap = amount * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

326:         auctionRound[currentRoundId].softCap = amount * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

326:         auctionRound[currentRoundId].softCap = amount * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

326:         auctionRound[currentRoundId].softCap = amount * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

326:         auctionRound[currentRoundId].softCap = amount * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

326:         auctionRound[currentRoundId].softCap = amount * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

326:         auctionRound[currentRoundId].softCap = amount * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

326:         auctionRound[currentRoundId].softCap = amount * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

326:         auctionRound[currentRoundId].softCap = amount * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

326:         auctionRound[currentRoundId].softCap = amount * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

333:         auctionRound[0].soyToSell = 29491750873668297408771; // auctionRound[0] * RATIO / 10**18 == 30 000 SOY for first day in daily auction.

333:         auctionRound[0].soyToSell = 29491750873668297408771; // auctionRound[0] * RATIO / 10**18 == 30 000 SOY for first day in daily auction.

333:         auctionRound[0].soyToSell = 29491750873668297408771; // auctionRound[0] * RATIO / 10**18 == 30 000 SOY for first day in daily auction.

333:         auctionRound[0].soyToSell = 29491750873668297408771; // auctionRound[0] * RATIO / 10**18 == 30 000 SOY for first day in daily auction.

333:         auctionRound[0].soyToSell = 29491750873668297408771; // auctionRound[0] * RATIO / 10**18 == 30 000 SOY for first day in daily auction.

333:         auctionRound[0].soyToSell = 29491750873668297408771; // auctionRound[0] * RATIO / 10**18 == 30 000 SOY for first day in daily auction.

351:         for (uint256 i = fromRound; i&lt;toRound; i++) {

351:         for (uint256 i = fromRound; i&lt;toRound; i++) {

353:             if (usdValue != 0) { // user contributed in this round

353:             if (usdValue != 0) { // user contributed in this round

354:                 if (bets[i][user].lockedUntil == 0) { // receive token from round

354:                 if (bets[i][user].lockedUntil == 0) { // receive token from round

355:                     uint256 total = auctionRound[i].soyToSell * usdValue / auctionRound[i].usdCollected;

355:                     uint256 total = auctionRound[i].soyToSell * usdValue / auctionRound[i].usdCollected;

356:                     uint256 locked = total * _lockPercentage / 100;

356:                     uint256 locked = total * _lockPercentage / 100;

357:                     soyToClaim += (total - locked);

357:                     soyToClaim += (total - locked);

359:                     bets[i][user].lockedUntil = auctionRound[i].end + _lockPeriod;

366:                 uint256 initialAmount = soyAmount * 100 / _lockPercentage;

366:                 uint256 initialAmount = soyAmount * 100 / _lockPercentage;

367:                 uint256 bonus = initialAmount * 25 / 100;   // 25% bonus

367:                 uint256 bonus = initialAmount * 25 / 100;   // 25% bonus

367:                 uint256 bonus = initialAmount * 25 / 100;   // 25% bonus

367:                 uint256 bonus = initialAmount * 25 / 100;   // 25% bonus

368:                 soyToClaim += (soyAmount + bonus);

368:                 soyToClaim += (soyAmount + bonus);

380:         for (uint256 i = 1; i &lt; toRound; i++) {

380:         for (uint256 i = 1; i &lt; toRound; i++) {

382:             if (usdValue != 0) { // user contributed in this round

382:             if (usdValue != 0) { // user contributed in this round

385:                 if (lockedUntil == 0) { // receive token from round

385:                 if (lockedUntil == 0) { // receive token from round

386:                     uint256 total = auctionRound[i].soyToSell * usdValue / auctionRound[i].usdCollected;

386:                     uint256 total = auctionRound[i].soyToSell * usdValue / auctionRound[i].usdCollected;

387:                     locked = total * _lockPercentage / 100;

387:                     locked = total * _lockPercentage / 100;

388:                     soyToClaim += (total - locked);

388:                     soyToClaim += (total - locked);

389:                     lockedUntil = auctionRound[i].end + _lockPeriod;

392:                     soyToClaim += bets[i][user].soyAmount;

393:                     soyToClaim += locked;   // in case of user do first claim in 1 year after auction end.

393:                     soyToClaim += locked;   // in case of user do first claim in 1 year after auction end.

393:                     soyToClaim += locked;   // in case of user do first claim in 1 year after auction end.

395:                     soyLocked += bets[i][user].soyAmount;

396:                     soyLocked += locked;

400:                     soyToClaim += bets[i][user].soyAmount;

402:                     soyLocked += bets[i][user].soyAmount;

414:         lockedSoy = new uint256[](currentRound-1);

415:         lockedDate = new uint256[](currentRound-1);

416:         soyPrice = new uint256[](currentRound-1);

420:         for (uint256 i = 1; i &lt; currentRound; i++) {

420:         for (uint256 i = 1; i &lt; currentRound; i++) {

422:             if (usdValue != 0) { // user contributed in this round

422:             if (usdValue != 0) { // user contributed in this round

425:                 if (lockedUntil == 0) { // receive token from round

425:                 if (lockedUntil == 0) { // receive token from round

426:                     uint256 total = auctionRound[i].soyToSell * usdValue / auctionRound[i].usdCollected;

426:                     uint256 total = auctionRound[i].soyToSell * usdValue / auctionRound[i].usdCollected;

427:                     locked = total * _lockPercentage / 100;

427:                     locked = total * _lockPercentage / 100;

428:                     soyToClaim += (total - locked);

428:                     soyToClaim += (total - locked);

429:                     lockedUntil = auctionRound[i].end + _lockPeriod;

430:                     lockedDate[i-1] = lockedUntil;

431:                     lockedSoy[i-1] = locked;

432:                     soyPrice[i-1] = auctionRound[i].usdCollected * 10**18 / auctionRound[i].soyToSell;

432:                     soyPrice[i-1] = auctionRound[i].usdCollected * 10**18 / auctionRound[i].soyToSell;

432:                     soyPrice[i-1] = auctionRound[i].usdCollected * 10**18 / auctionRound[i].soyToSell;

432:                     soyPrice[i-1] = auctionRound[i].usdCollected * 10**18 / auctionRound[i].soyToSell;

432:                     soyPrice[i-1] = auctionRound[i].usdCollected * 10**18 / auctionRound[i].soyToSell;

435:                     soyToClaim += bets[i][user].soyAmount;

436:                     soyToClaim += locked;   // in case of user do first claim in 1 year after auction end.

436:                     soyToClaim += locked;   // in case of user do first claim in 1 year after auction end.

436:                     soyToClaim += locked;   // in case of user do first claim in 1 year after auction end.

438:                     soyLocked += bets[i][user].soyAmount;

439:                     soyLocked += locked;

442:                 lockedDate[i-1] = bets[i][user].lockedUntil;

443:                 lockedSoy[i-1] = bets[i][user].soyAmount;

444:                 soyPrice[i-1] = auctionRound[i].usdCollected * 10**18 / auctionRound[i].soyToSell;                

444:                 soyPrice[i-1] = auctionRound[i].usdCollected * 10**18 / auctionRound[i].soyToSell;                

444:                 soyPrice[i-1] = auctionRound[i].usdCollected * 10**18 / auctionRound[i].soyToSell;                

444:                 soyPrice[i-1] = auctionRound[i].usdCollected * 10**18 / auctionRound[i].soyToSell;                

444:                 soyPrice[i-1] = auctionRound[i].usdCollected * 10**18 / auctionRound[i].soyToSell;                

445:                 if (lockedDate[i-1] &lt; block.timestamp) {

446:                     soyToClaim += lockedSoy[i-1];

446:                     soyToClaim += lockedSoy[i-1];

448:                     soyLocked += lockedSoy[i-1];

448:                     soyLocked += lockedSoy[i-1];

459:         for (uint i=1; i&lt;=currentRound; i++) {

459:         for (uint i=1; i&lt;=currentRound; i++) {

472:             totalSoyToSell += _value;

476:         userBet(_from, msg.sender, _value); // user, token, amount

476:         userBet(_from, msg.sender, _value); // user, token, amount

496:         if (checkRound()) // if last round finished - return money to sender.

496:         if (checkRound()) // if last round finished - return money to sender.

496:         if (checkRound()) // if last round finished - return money to sender.

505:         uint256 totalUSD = round.usdCollected + (amount * price / 10**18);

505:         uint256 totalUSD = round.usdCollected + (amount * price / 10**18);

505:         uint256 totalUSD = round.usdCollected + (amount * price / 10**18);

505:         uint256 totalUSD = round.usdCollected + (amount * price / 10**18);

505:         uint256 totalUSD = round.usdCollected + (amount * price / 10**18);

507:             uint256 rest = totalUSD - round.hardCap; // rest of USD

507:             uint256 rest = totalUSD - round.hardCap; // rest of USD

507:             uint256 rest = totalUSD - round.hardCap; // rest of USD

508:             rest = rest * 10**18 / price; // rest in token

508:             rest = rest * 10**18 / price; // rest in token

508:             rest = rest * 10**18 / price; // rest in token

508:             rest = rest * 10**18 / price; // rest in token

508:             rest = rest * 10**18 / price; // rest in token

508:             rest = rest * 10**18 / price; // rest in token

509:             if (rest &gt; amount) rest = amount; // this condition shouldn&#39;t be true but added to be safe.

509:             if (rest &gt; amount) rest = amount; // this condition shouldn&#39;t be true but added to be safe.

511:             amount = amount - rest; // amount of token that bet in this round

511:             amount = amount - rest; // amount of token that bet in this round

511:             amount = amount - rest; // amount of token that bet in this round

513:             if (rest != 0) transferTo(token, rest, user); // return rest to the user

513:             if (rest != 0) transferTo(token, rest, user); // return rest to the user

517:         uint256 usdValue = amount * price / 10**18;

517:         uint256 usdValue = amount * price / 10**18;

517:         uint256 usdValue = amount * price / 10**18;

517:         uint256 usdValue = amount * price / 10**18;

518:         bet.usdValue += usdValue;    // update user&#39;s bet

518:         bet.usdValue += usdValue;    // update user&#39;s bet

518:         bet.usdValue += usdValue;    // update user&#39;s bet

519:         transferTo(token, amount, bank);    // transfer token to the bank address

519:         transferTo(token, amount, bank);    // transfer token to the bank address

524:         currentRoundId++;

524:         currentRoundId++;

528:         round.end = startTime + roundDuration;

532:             soyToSell = auctionRound[currentRoundId - 1].soyToSell * RATIO / 10**18;

532:             soyToSell = auctionRound[currentRoundId - 1].soyToSell * RATIO / 10**18;

532:             soyToSell = auctionRound[currentRoundId - 1].soyToSell * RATIO / 10**18;

532:             soyToSell = auctionRound[currentRoundId - 1].soyToSell * RATIO / 10**18;

532:             soyToSell = auctionRound[currentRoundId - 1].soyToSell * RATIO / 10**18;

533:             if ((totalSoyToSell - totalSoySold) &lt; soyToSell) {

534:                 soyToSell = totalSoyToSell - totalSoySold;  // if left less Soy then we need due to calculation - sell all available Soy

534:                 soyToSell = totalSoyToSell - totalSoySold;  // if left less Soy then we need due to calculation - sell all available Soy

534:                 soyToSell = totalSoyToSell - totalSoySold;  // if left less Soy then we need due to calculation - sell all available Soy

534:                 soyToSell = totalSoyToSell - totalSoySold;  // if left less Soy then we need due to calculation - sell all available Soy

537:             uint256 roundsLeft = auctionRounds + 1 - currentRoundId;

537:             uint256 roundsLeft = auctionRounds + 1 - currentRoundId;

538:             soyToSell = (totalSoyToSell - totalSoySold) / roundsLeft;

538:             soyToSell = (totalSoyToSell - totalSoySold) / roundsLeft;

542:         totalSoySold += soyToSell;

543:         round.hardCap = soyToSell * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

543:         round.hardCap = soyToSell * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

543:         round.hardCap = soyToSell * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

543:         round.hardCap = soyToSell * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

543:         round.hardCap = soyToSell * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

543:         round.hardCap = soyToSell * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

543:         round.hardCap = soyToSell * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

543:         round.hardCap = soyToSell * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

543:         round.hardCap = soyToSell * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

543:         round.hardCap = soyToSell * lastRoundSoyPrice * maxPricePercentage / 10**20;    // 100 * 10**18

544:         round.softCap = soyToSell * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

544:         round.softCap = soyToSell * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

544:         round.softCap = soyToSell * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

544:         round.softCap = soyToSell * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

544:         round.softCap = soyToSell * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

544:         round.softCap = soyToSell * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

544:         round.softCap = soyToSell * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

544:         round.softCap = soyToSell * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

544:         round.softCap = soyToSell * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

544:         round.softCap = soyToSell * lastRoundSoyPrice * minPricePercentage / 10**20;    // 100 * 10**18

550:         lastRoundSoyPrice = round.usdCollected * 10**18 / round.soyToSell;

550:         lastRoundSoyPrice = round.usdCollected * 10**18 / round.soyToSell;

550:         lastRoundSoyPrice = round.usdCollected * 10**18 / round.soyToSell;

550:         lastRoundSoyPrice = round.usdCollected * 10**18 / round.soyToSell;

552:         if (currentRoundId == auctionRounds) {  // last round

552:         if (currentRoundId == auctionRounds) {  // last round

553:             currentRoundId++;

553:             currentRoundId++;

556:             startRound(endTime);  // start new round when previous round ends

556:             startRound(endTime);  // start new round when previous round ends

566:         if (round.end &lt;= block.timestamp) { // auction round finished.

566:         if (round.end &lt;= block.timestamp) { // auction round finished.

569:                 uint256 duration = (block.timestamp - round.start) / roundDuration;

569:                 uint256 duration = (block.timestamp - round.start) / roundDuration;

571:                     round.end = round.start + ((duration+1)*roundDuration);

571:                     round.end = round.start + ((duration+1)*roundDuration);

571:                     round.end = round.start + ((duration+1)*roundDuration);

573:                     round.end = round.start + (maxExtendRounds * roundDuration);

573:                     round.end = round.start + (maxExtendRounds * roundDuration);

584:         if (token == address(1)) {   // transfer CLO 

584:         if (token == address(1)) {   // transfer CLO 

599:             amount = totalSoyToSell-totalSoySold;

610:         uint256 amountAvailable = totalSoyToSell - totalSoySold - burntAmount;

610:         uint256 amountAvailable = totalSoyToSell - totalSoySold - burntAmount;

613:         burntAmount += amount;

618:         for (uint256 i = 1; i &lt; currentRoundId; i++) {

618:         for (uint256 i = 1; i &lt; currentRoundId; i++) {
</code></pre>
            <pre class="solidity"><code>File: IDO/priceFeed.sol

69:     mapping(address =&gt; uint256) internal _price;    // token price

69:     mapping(address =&gt; uint256) internal _price;    // token price

100:         for (uint i=0; i&lt;token.length; i++) {

100:         for (uint i=0; i&lt;token.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

326:         return functionCall(target, data, &quot;Address: low-level call failed&quot;);

359:         return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);

375:         require(isContract(target), &quot;Address: call to non-contract&quot;);

389:         return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);

403:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

417:         return functionDelegateCall(target, data, &quot;Address: low-level delegate call failed&quot;);

431:         require(isContract(target), &quot;Address: delegate call to non-contract&quot;);

513:             &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;

513:             &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;

523:         uint256 newAllowance = token.allowance(address(this), spender) + value;

535:             uint256 newAllowance = oldAllowance - value;

551:         bytes memory returndata = address(token).functionCall(data, &quot;SafeERC20: low-level call failed&quot;);

680:     uint256 public constant MIN_LENGTH_LOTTERY = 4 hours - 5 minutes; // 4 hours

680:     uint256 public constant MIN_LENGTH_LOTTERY = 4 hours - 5 minutes; // 4 hours

680:     uint256 public constant MIN_LENGTH_LOTTERY = 4 hours - 5 minutes; // 4 hours

681:     uint256 public constant MAX_LENGTH_LOTTERY = 4 days + 5 minutes; // 4 days

681:     uint256 public constant MAX_LENGTH_LOTTERY = 4 days + 5 minutes; // 4 days

681:     uint256 public constant MAX_LENGTH_LOTTERY = 4 days + 5 minutes; // 4 days

682:     uint256 public constant MAX_TREASURY_FEE = 3000; // 30%

682:     uint256 public constant MAX_TREASURY_FEE = 3000; // 30%

700:         uint256[6] rewardsBreakdown; // 0: 1 matching number // 5: 6 matching numbers

700:         uint256[6] rewardsBreakdown; // 0: 1 matching number // 5: 6 matching numbers

700:         uint256[6] rewardsBreakdown; // 0: 1 matching number // 5: 6 matching numbers

700:         uint256[6] rewardsBreakdown; // 0: 1 matching number // 5: 6 matching numbers

701:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

701:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

701:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

701:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

701:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

701:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

809:         _lotteries[_lotteryId].amountCollectedInCake += amountCakeToTransfer;

811:         for (uint256 i = 0; i &lt; _ticketNumbers.length; i++) {

811:         for (uint256 i = 0; i &lt; _ticketNumbers.length; i++) {

816:             _numberTicketsPerLotteryId[_lotteryId][1 + (thisTicketNumber % 10)]++;

816:             _numberTicketsPerLotteryId[_lotteryId][1 + (thisTicketNumber % 10)]++;

816:             _numberTicketsPerLotteryId[_lotteryId][1 + (thisTicketNumber % 10)]++;

817:             _numberTicketsPerLotteryId[_lotteryId][11 + (thisTicketNumber % 100)]++;

817:             _numberTicketsPerLotteryId[_lotteryId][11 + (thisTicketNumber % 100)]++;

817:             _numberTicketsPerLotteryId[_lotteryId][11 + (thisTicketNumber % 100)]++;

818:             _numberTicketsPerLotteryId[_lotteryId][111 + (thisTicketNumber % 1000)]++;

818:             _numberTicketsPerLotteryId[_lotteryId][111 + (thisTicketNumber % 1000)]++;

818:             _numberTicketsPerLotteryId[_lotteryId][111 + (thisTicketNumber % 1000)]++;

819:             _numberTicketsPerLotteryId[_lotteryId][1111 + (thisTicketNumber % 10000)]++;

819:             _numberTicketsPerLotteryId[_lotteryId][1111 + (thisTicketNumber % 10000)]++;

819:             _numberTicketsPerLotteryId[_lotteryId][1111 + (thisTicketNumber % 10000)]++;

820:             _numberTicketsPerLotteryId[_lotteryId][11111 + (thisTicketNumber % 100000)]++;

820:             _numberTicketsPerLotteryId[_lotteryId][11111 + (thisTicketNumber % 100000)]++;

820:             _numberTicketsPerLotteryId[_lotteryId][11111 + (thisTicketNumber % 100000)]++;

821:             _numberTicketsPerLotteryId[_lotteryId][111111 + (thisTicketNumber % 1000000)]++;

821:             _numberTicketsPerLotteryId[_lotteryId][111111 + (thisTicketNumber % 1000000)]++;

821:             _numberTicketsPerLotteryId[_lotteryId][111111 + (thisTicketNumber % 1000000)]++;

828:             currentTicketId++;

828:             currentTicketId++;

854:         for (uint256 i = 0; i &lt; _ticketIds.length; i++) {

854:         for (uint256 i = 0; i &lt; _ticketIds.length; i++) {

855:             require(_brackets[i] &lt; 6, &quot;Bracket out of range&quot;); // Must be between 0 and 5

855:             require(_brackets[i] &lt; 6, &quot;Bracket out of range&quot;); // Must be between 0 and 5

873:                     _calculateRewardsForTicketId(_lotteryId, thisTicketId, _brackets[i] + 1) == 0,

879:             rewardInCakeToTransfer += rewardForTicketId;

929:             ((_lotteries[_lotteryId].amountCollectedInCake) * (10000 - _lotteries[_lotteryId].treasuryFee))

929:             ((_lotteries[_lotteryId].amountCollectedInCake) * (10000 - _lotteries[_lotteryId].treasuryFee))

930:         ) / 10000;

936:         for (uint32 i = 0; i &lt; 6; i++) {

936:         for (uint32 i = 0; i &lt; 6; i++) {

937:             uint32 j = 5 - i;

938:             uint32 transformedWinningNumber = _bracketCalculator[j] + (finalNumber % (uint32(10)**(j + 1)));

938:             uint32 transformedWinningNumber = _bracketCalculator[j] + (finalNumber % (uint32(10)**(j + 1)));

938:             uint32 transformedWinningNumber = _bracketCalculator[j] + (finalNumber % (uint32(10)**(j + 1)));

938:             uint32 transformedWinningNumber = _bracketCalculator[j] + (finalNumber % (uint32(10)**(j + 1)));

941:                 _numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] -

946:                 (_numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] - numberAddressesInPreviousBracket) !=

952:                         ((_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) /

952:                         ((_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) /

953:                             (_numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] -

954:                                 numberAddressesInPreviousBracket)) /

964:                 amountToWithdrawToTreasury +=

965:                     (_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) /

965:                     (_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) /

979:         amountToWithdrawToTreasury += (_lotteries[_lotteryId].amountCollectedInCake - amountToShareToWinners);

979:         amountToWithdrawToTreasury += (_lotteries[_lotteryId].amountCollectedInCake - amountToShareToWinners);

1020:         _lotteries[_lotteryId].amountCollectedInCake += _amount;

1047:             ((_endTime - block.timestamp) &gt; MIN_LENGTH_LOTTERY) &amp;&amp; ((_endTime - block.timestamp) &lt; MAX_LENGTH_LOTTERY),

1047:             ((_endTime - block.timestamp) &gt; MIN_LENGTH_LOTTERY) &amp;&amp; ((_endTime - block.timestamp) &lt; MAX_LENGTH_LOTTERY),

1060:             (_rewardsBreakdown[0] +

1061:                 _rewardsBreakdown[1] +

1062:                 _rewardsBreakdown[2] +

1063:                 _rewardsBreakdown[3] +

1064:                 _rewardsBreakdown[4] +

1069:         currentLotteryId++;

1069:         currentLotteryId++;

1206:         for (uint256 i = 0; i &lt; length; i++) {

1206:         for (uint256 i = 0; i &lt; length; i++) {

1271:         if (length &gt; (numberTicketsBoughtAtLotteryId - _cursor)) {

1272:             length = numberTicketsBoughtAtLotteryId - _cursor;

1279:         for (uint256 i = 0; i &lt; length; i++) {

1279:         for (uint256 i = 0; i &lt; length; i++) {

1280:             lotteryTicketIds[i] = _userTicketIdsPerLotteryId[_user][_lotteryId][i + _cursor];

1292:         return (lotteryTicketIds, ticketNumbers, ticketStatuses, _cursor + length);

1313:         uint32 transformedWinningNumber = _bracketCalculator[_bracket] +

1314:             (winningTicketNumber % (uint32(10)**(_bracket + 1)));

1314:             (winningTicketNumber % (uint32(10)**(_bracket + 1)));

1314:             (winningTicketNumber % (uint32(10)**(_bracket + 1)));

1316:         uint32 transformedUserNumber = _bracketCalculator[_bracket] + (userNumber % (uint32(10)**(_bracket + 1)));

1316:         uint32 transformedUserNumber = _bracketCalculator[_bracket] + (userNumber % (uint32(10)**(_bracket + 1)));

1316:         uint32 transformedUserNumber = _bracketCalculator[_bracket] + (userNumber % (uint32(10)**(_bracket + 1)));

1316:         uint32 transformedUserNumber = _bracketCalculator[_bracket] + (userNumber % (uint32(10)**(_bracket + 1)));

1337:         return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;

1337:         return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;

1337:         return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;

1337:         return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;

1337:         return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;
</code></pre>
            <pre class="solidity"><code>File: Lottery/RandomNumberGenerator.sol

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

263:         return functionCall(target, data, &quot;Address: low-level call failed&quot;);

296:         return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);

312:         require(isContract(target), &quot;Address: call to non-contract&quot;);

326:         return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);

340:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

354:         return functionDelegateCall(target, data, &quot;Address: low-level delegate call failed&quot;);

368:         require(isContract(target), &quot;Address: delegate call to non-contract&quot;);

450:             &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;

450:             &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;

460:         uint256 newAllowance = token.allowance(address(this), spender) + value;

472:             uint256 newAllowance = oldAllowance - value;

488:         bytes memory returndata = address(token).functionCall(data, &quot;SafeERC20: low-level call failed&quot;);

733:         nonces[_keyHash] = nonces[_keyHash] + 1;

743:     mapping(bytes32 =&gt; uint256) /* keyHash */ /* nonce */

743:     mapping(bytes32 =&gt; uint256) /* keyHash */ /* nonce */

743:     mapping(bytes32 =&gt; uint256) /* keyHash */ /* nonce */

743:     mapping(bytes32 =&gt; uint256) /* keyHash */ /* nonce */

743:     mapping(bytes32 =&gt; uint256) /* keyHash */ /* nonce */

743:     mapping(bytes32 =&gt; uint256) /* keyHash */ /* nonce */

743:     mapping(bytes32 =&gt; uint256) /* keyHash */ /* nonce */

743:     mapping(bytes32 =&gt; uint256) /* keyHash */ /* nonce */

950:         randomResult = uint32(1000000 + (randomness % 1000000));
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

27:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

326:         return functionCall(target, data, &quot;Address: low-level call failed&quot;);

359:         return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);

375:         require(isContract(target), &quot;Address: call to non-contract&quot;);

389:         return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);

403:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

417:         return functionDelegateCall(target, data, &quot;Address: low-level delegate call failed&quot;);

431:         require(isContract(target), &quot;Address: delegate call to non-contract&quot;);

513:             &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;

513:             &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;

523:         uint256 newAllowance = token.allowance(address(this), spender) + value;

535:             uint256 newAllowance = oldAllowance - value;

551:         bytes memory returndata = address(token).functionCall(data, &quot;SafeERC20: low-level call failed&quot;);

664:     uint256 constant MAX_BRACKETS = 3;  // maximum winning combination (i.e. first 1, first 2, first 3, ...). (Default: 6)

664:     uint256 constant MAX_BRACKETS = 3;  // maximum winning combination (i.e. first 1, first 2, first 3, ...). (Default: 6)

681:     uint256 public constant MIN_LENGTH_LOTTERY = 1 hours - 5 minutes; // 4 hours

681:     uint256 public constant MIN_LENGTH_LOTTERY = 1 hours - 5 minutes; // 4 hours

681:     uint256 public constant MIN_LENGTH_LOTTERY = 1 hours - 5 minutes; // 4 hours

682:     uint256 public constant MAX_LENGTH_LOTTERY = 4 days + 5 minutes; // 4 days

682:     uint256 public constant MAX_LENGTH_LOTTERY = 4 days + 5 minutes; // 4 days

682:     uint256 public constant MAX_LENGTH_LOTTERY = 4 days + 5 minutes; // 4 days

683:     uint256 public constant MAX_TREASURY_FEE = 3000; // 30%

683:     uint256 public constant MAX_TREASURY_FEE = 3000; // 30%

701:         uint256[6] rewardsBreakdown; // 0: 1 matching number // 5: 6 matching numbers

701:         uint256[6] rewardsBreakdown; // 0: 1 matching number // 5: 6 matching numbers

701:         uint256[6] rewardsBreakdown; // 0: 1 matching number // 5: 6 matching numbers

701:         uint256[6] rewardsBreakdown; // 0: 1 matching number // 5: 6 matching numbers

702:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

702:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

702:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

702:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

702:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

702:         uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%

810:         _lotteries[_lotteryId].amountCollectedInSoy += amountSoyToTransfer;

812:         for (uint256 i = 0; i &lt; _ticketNumbers.length; i++) {

812:         for (uint256 i = 0; i &lt; _ticketNumbers.length; i++) {

818:             _numberTicketsPerLotteryId[_lotteryId][1 + (thisTicketNumber % 10)]++;

818:             _numberTicketsPerLotteryId[_lotteryId][1 + (thisTicketNumber % 10)]++;

818:             _numberTicketsPerLotteryId[_lotteryId][1 + (thisTicketNumber % 10)]++;

819:             _numberTicketsPerLotteryId[_lotteryId][11 + (thisTicketNumber % 100)]++;

819:             _numberTicketsPerLotteryId[_lotteryId][11 + (thisTicketNumber % 100)]++;

819:             _numberTicketsPerLotteryId[_lotteryId][11 + (thisTicketNumber % 100)]++;

820:             _numberTicketsPerLotteryId[_lotteryId][111 + (thisTicketNumber % 1000)]++;

820:             _numberTicketsPerLotteryId[_lotteryId][111 + (thisTicketNumber % 1000)]++;

820:             _numberTicketsPerLotteryId[_lotteryId][111 + (thisTicketNumber % 1000)]++;

830:             currentTicketId++;

830:             currentTicketId++;

856:         for (uint256 i = 0; i &lt; _ticketIds.length; i++) {

856:         for (uint256 i = 0; i &lt; _ticketIds.length; i++) {

857:             require(_brackets[i] &lt; MAX_BRACKETS, &quot;Bracket out of range&quot;); // Must be between 0 and 5

857:             require(_brackets[i] &lt; MAX_BRACKETS, &quot;Bracket out of range&quot;); // Must be between 0 and 5

873:             if (_brackets[i] != (MAX_BRACKETS-1)) {

875:                     _calculateRewardsForTicketId(_lotteryId, thisTicketId, _brackets[i] + 1) == 0,

881:             rewardInSoyToTransfer += rewardForTicketId;

932:             ((_lotteries[_lotteryId].amountCollectedInSoy) * (10000 - _lotteries[_lotteryId].treasuryFee))

932:             ((_lotteries[_lotteryId].amountCollectedInSoy) * (10000 - _lotteries[_lotteryId].treasuryFee))

933:         ) / 10000;

939:         for (uint32 i = 0; i &lt; MAX_BRACKETS; i++) {

939:         for (uint32 i = 0; i &lt; MAX_BRACKETS; i++) {

940:             uint32 j = uint32(MAX_BRACKETS-1) - i;

940:             uint32 j = uint32(MAX_BRACKETS-1) - i;

941:             uint32 transformedWinningNumber = _bracketCalculator[j] + (finalNumber % (uint32(10)**(j + 1)));

941:             uint32 transformedWinningNumber = _bracketCalculator[j] + (finalNumber % (uint32(10)**(j + 1)));

941:             uint32 transformedWinningNumber = _bracketCalculator[j] + (finalNumber % (uint32(10)**(j + 1)));

941:             uint32 transformedWinningNumber = _bracketCalculator[j] + (finalNumber % (uint32(10)**(j + 1)));

944:                 _numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] -

949:                 (_numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] - numberAddressesInPreviousBracket) !=

955:                         ((_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) /

955:                         ((_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) /

956:                             (_numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] -

957:                                 numberAddressesInPreviousBracket)) /

967:                 amountToWithdrawToTreasury +=

968:                     (_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) /

968:                     (_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) /

982:         amountToWithdrawToTreasury += (_lotteries[_lotteryId].amountCollectedInSoy - amountToShareToWinners);

982:         amountToWithdrawToTreasury += (_lotteries[_lotteryId].amountCollectedInSoy - amountToShareToWinners);

1023:         _lotteries[_lotteryId].amountCollectedInSoy += _amount;

1050:             ((_endTime - block.timestamp) &gt; MIN_LENGTH_LOTTERY) &amp;&amp; ((_endTime - block.timestamp) &lt; MAX_LENGTH_LOTTERY),

1050:             ((_endTime - block.timestamp) &gt; MIN_LENGTH_LOTTERY) &amp;&amp; ((_endTime - block.timestamp) &lt; MAX_LENGTH_LOTTERY),

1063:             (_rewardsBreakdown[0] +

1064:                 _rewardsBreakdown[1] +

1065:                 _rewardsBreakdown[2] +

1066:                 _rewardsBreakdown[3] +

1067:                 _rewardsBreakdown[4] +

1072:         currentLotteryId++;

1072:         currentLotteryId++;

1209:         for (uint256 i = 0; i &lt; length; i++) {

1209:         for (uint256 i = 0; i &lt; length; i++) {

1274:         if (length &gt; (numberTicketsBoughtAtLotteryId - _cursor)) {

1275:             length = numberTicketsBoughtAtLotteryId - _cursor;

1282:         for (uint256 i = 0; i &lt; length; i++) {

1282:         for (uint256 i = 0; i &lt; length; i++) {

1283:             lotteryTicketIds[i] = _userTicketIdsPerLotteryId[_user][_lotteryId][i + _cursor];

1295:         return (lotteryTicketIds, ticketNumbers, ticketStatuses, _cursor + length);

1316:         uint32 transformedWinningNumber = _bracketCalculator[_bracket] +

1317:             (winningTicketNumber % (uint32(10)**(_bracket + 1)));

1317:             (winningTicketNumber % (uint32(10)**(_bracket + 1)));

1317:             (winningTicketNumber % (uint32(10)**(_bracket + 1)));

1319:         uint32 transformedUserNumber = _bracketCalculator[_bracket] + (userNumber % (uint32(10)**(_bracket + 1)));

1319:         uint32 transformedUserNumber = _bracketCalculator[_bracket] + (userNumber % (uint32(10)**(_bracket + 1)));

1319:         uint32 transformedUserNumber = _bracketCalculator[_bracket] + (userNumber % (uint32(10)**(_bracket + 1)));

1319:         uint32 transformedUserNumber = _bracketCalculator[_bracket] + (userNumber % (uint32(10)**(_bracket + 1)));

1340:         return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;

1340:         return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;

1340:         return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;

1340:         return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;

1340:         return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyRandomNumberGenerator.sol

177:         uint256 requestId;  // equal to lottery ID that made request

177:         uint256 requestId;  // equal to lottery ID that made request

178:         uint256 seed;   // seed from request

178:         uint256 seed;   // seed from request

179:         bytes32 blockHash1; // the prior request block hash 

179:         bytes32 blockHash1; // the prior request block hash 

180:         uint256 commitBlock;    // block number of commit

180:         uint256 commitBlock;    // block number of commit

181:         bytes32 secretHash; // hash of secret random number

181:         bytes32 secretHash; // hash of secret random number

205:         entropy.blockHash1 = blockhash(block.number-1);

206:         entropy.commitBlock = 0;    // clear last record of block number

206:         entropy.commitBlock = 0;    // clear last record of block number

223:         require(commitBlock != 0 &amp;&amp; commitBlock + 1 &lt; block.number, &quot;Reveal not allowed&quot;);  // allow reveal at least in 2 blocks after commitment

223:         require(commitBlock != 0 &amp;&amp; commitBlock + 1 &lt; block.number, &quot;Reveal not allowed&quot;);  // allow reveal at least in 2 blocks after commitment

223:         require(commitBlock != 0 &amp;&amp; commitBlock + 1 &lt; block.number, &quot;Reveal not allowed&quot;);  // allow reveal at least in 2 blocks after commitment

224:         if (block.number - commitBlock &gt; 256) {

225:             entropy.commitBlock = 0;    // allow to repeat commitment

225:             entropy.commitBlock = 0;    // allow to repeat commitment

226:             emit RandomNumber(0);   // random number generating is failed

226:             emit RandomNumber(0);   // random number generating is failed

229:         bytes32 blockHash2 = blockhash(commitBlock + 1); // hash of next block after commitment

229:         bytes32 blockHash2 = blockhash(commitBlock + 1); // hash of next block after commitment

229:         bytes32 blockHash2 = blockhash(commitBlock + 1); // hash of next block after commitment

232:         randomResult = uint32(1000 + (randomness % 1000));

239:         entropy.commitBlock = 0;    // allow to repeat commitment

239:         entropy.commitBlock = 0;    // allow to repeat commitment

240:         emit RandomNumber(0);   // random number generating is failed

240:         emit RandomNumber(0);   // random number generating is failed
</code></pre>
            <pre class="solidity"><code>File: Muticall2.sol

22:         for(uint256 i = 0; i &lt; calls.length; i++) {

22:         for(uint256 i = 0; i &lt; calls.length; i++) {

53:         blockHash = blockhash(block.number - 1);

57:         for(uint256 i = 0; i &lt; calls.length; i++) {

57:         for(uint256 i = 0; i &lt; calls.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Old/CLOE_ERC20.sol

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

138:     uint256 c = a + b;

168:     uint256 c = a - b;

190:     uint256 c = a * b;

191:     require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

225:     uint256 c = a / b;

337:   mapping(address =&gt; bool) public gateways; // different gateways will be used for different pairs (chains)

337:   mapping(address =&gt; bool) public gateways; // different gateways will be used for different pairs (chains)

343:   uint256 constant public MAX_SUPPLY = 125000000 ether;  //Max supply 125,000,000 tokens

343:   uint256 constant public MAX_SUPPLY = 125000000 ether;  //Max supply 125,000,000 tokens

364:     _mint(0x4667d0c30E6f58ef935ddAb560d41E030E4d2AeB, 1000000 ether); // mint 1.000.000 for investors

364:     _mint(0x4667d0c30E6f58ef935ddAb560d41E030E4d2AeB, 1000000 ether); // mint 1.000.000 for investors
</code></pre>
            <pre class="solidity"><code>File: Old/SOY_ERC20.sol

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

109:     this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

138:     uint256 c = a + b;

168:     uint256 c = a - b;

190:     uint256 c = a * b;

191:     require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

225:     uint256 c = a / b;

337:   mapping(address =&gt; bool) public gateways; // different gateways will be used for different pairs (chains)

337:   mapping(address =&gt; bool) public gateways; // different gateways will be used for different pairs (chains)
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceFactory.sol

115:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

115:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

115:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

115:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

119:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

119:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

119:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

119:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

123:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

123:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

123:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

123:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

123:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

137:     string public constant symbol = &#39;SOY-LP&#39;;

201:         if (allowance[from][msg.sender] != uint(-1)) {

214:                 keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))

214:                 keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))

239:             uint x = y / 2 + 1;

239:             uint x = y / 2 + 1;

242:                 x = (y / x + x) / 2;

242:                 x = (y / x + x) / 2;

242:                 x = (y / x + x) / 2;

261:     uint224 constant Q112 = 2**112;

261:     uint224 constant Q112 = 2**112;

265:         z = uint224(y) * Q112; // never overflows

265:         z = uint224(y) * Q112; // never overflows

265:         z = uint224(y) * Q112; // never overflows

270:         z = x / uint224(y);

319:     uint public constant MINIMUM_LIQUIDITY = 10**3;

319:     uint public constant MINIMUM_LIQUIDITY = 10**3;

326:     uint112 private reserve0;           // uses single storage slot, accessible via getReserves

326:     uint112 private reserve0;           // uses single storage slot, accessible via getReserves

327:     uint112 private reserve1;           // uses single storage slot, accessible via getReserves

327:     uint112 private reserve1;           // uses single storage slot, accessible via getReserves

328:     uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves

328:     uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves

332:     uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event

332:     uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event

332:     uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event

371:         require(msg.sender == factory, &#39;SoyFinance: FORBIDDEN&#39;); // sufficient check

371:         require(msg.sender == factory, &#39;SoyFinance: FORBIDDEN&#39;); // sufficient check

378:         require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#39;SoyFinance: OVERFLOW&#39;);

378:         require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#39;SoyFinance: OVERFLOW&#39;);

379:         uint32 blockTimestamp = uint32(block.timestamp % 2**32);

379:         uint32 blockTimestamp = uint32(block.timestamp % 2**32);

380:         uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired

380:         uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired

380:         uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired

383:             price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;

383:             price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;

384:             price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;

384:             price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;

396:         uint _kLast = kLast; // gas savings

396:         uint _kLast = kLast; // gas savings

404:                     uint liquidity = numerator / denominator;

415:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

415:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

422:         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

422:         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

425:            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens

425:            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens

427:             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);

427:             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);

433:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

433:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

433:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

433:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

439:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

439:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

440:         address _token0 = token0;                                // gas savings

440:         address _token0 = token0;                                // gas savings

441:         address _token1 = token1;                                // gas savings

441:         address _token1 = token1;                                // gas savings

447:         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

447:         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

448:         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution

448:         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution

448:         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution

448:         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution

449:         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution

449:         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution

449:         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution

449:         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution

458:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

458:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

458:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

458:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

465:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

465:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

470:         { // scope for _token{0,1}, avoids stack too deep errors

470:         { // scope for _token{0,1}, avoids stack too deep errors

474:         if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens

474:         if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens

475:         if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens

475:         if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens

480:         uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;

480:         uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;

480:         uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;

481:         uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;

481:         uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;

481:         uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;

483:         { // scope for reserve{0,1}Adjusted, avoids stack too deep errors

483:         { // scope for reserve{0,1}Adjusted, avoids stack too deep errors

486:         require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#39;SoyFinance: K&#39;);

486:         require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#39;SoyFinance: K&#39;);

495:         address _token0 = token0; // gas savings

495:         address _token0 = token0; // gas savings

496:         address _token1 = token1; // gas savings

496:         address _token1 = token1; // gas savings

536:         require(getPair[token0][token1] == address(0), &#39;SoyFinance: PAIR_EXISTS&#39;); // single check is sufficient

536:         require(getPair[token0][token1] == address(0), &#39;SoyFinance: PAIR_EXISTS&#39;); // single check is sufficient

544:         getPair[token1][token0] = pair; // populate mapping in the reverse direction

544:         getPair[token1][token0] = pair; // populate mapping in the reverse direction
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

264:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

264:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

264:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

264:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

268:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

268:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

268:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

268:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

272:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

272:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

272:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

272:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

272:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

299:                 hex&#39;6dc7455e5d9aec56bfab910b5d5ba32e651622de80b3e46a9e471b0c42cce641&#39; // init code hash

299:                 hex&#39;6dc7455e5d9aec56bfab910b5d5ba32e651622de80b3e46a9e471b0c42cce641&#39; // init code hash

315:         amountB = amountA.mul(reserveB) / reserveA;

325:         amountOut = numerator / denominator;

334:         amountIn = (numerator / denominator).add(1);

342:         for (uint i; i &lt; path.length - 1; i++) {

342:         for (uint i; i &lt; path.length - 1; i++) {

342:         for (uint i; i &lt; path.length - 1; i++) {

343:             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);

344:             amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);

352:         amounts[amounts.length - 1] = amountOut;

353:         for (uint i = path.length - 1; i &gt; 0; i--) {

353:         for (uint i = path.length - 1; i &gt; 0; i--) {

353:         for (uint i = path.length - 1; i &gt; 0; i--) {

354:             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);

355:             amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);

419:         assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract

419:         assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract

489:         if (msg.value &gt; amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);

503:         ISoyFinancePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair

503:         ISoyFinancePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair

542:         uint value = approveMax ? uint(-1) : liquidity;

556:         uint value = approveMax ? uint(-1) : liquidity;

593:         uint value = approveMax ? uint(-1) : liquidity;

603:         for (uint i; i &lt; path.length - 1; i++) {

603:         for (uint i; i &lt; path.length - 1; i++) {

603:         for (uint i; i &lt; path.length - 1; i++) {

604:             (address input, address output) = (path[i], path[i + 1]);

606:             uint amountOut = amounts[i + 1];

608:             address to = i &lt; path.length - 2 ? SoyFinanceLibrary.pairFor(factory, output, path[i + 2]) : _to;

608:             address to = i &lt; path.length - 2 ? SoyFinanceLibrary.pairFor(factory, output, path[i + 2]) : _to;

622:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

652:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

664:         require(path[path.length - 1] == WETH, &#39;SoyFinanceRouter: INVALID_PATH&#39;);

671:         IWETH(WETH).withdraw(amounts[amounts.length - 1]);

672:         TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);

681:         require(path[path.length - 1] == WETH, &#39;SoyFinanceRouter: INVALID_PATH&#39;);

683:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

688:         IWETH(WETH).withdraw(amounts[amounts.length - 1]);

689:         TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);

706:         if (msg.value &gt; amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);

712:         for (uint i; i &lt; path.length - 1; i++) {

712:         for (uint i; i &lt; path.length - 1; i++) {

712:         for (uint i; i &lt; path.length - 1; i++) {

713:             (address input, address output) = (path[i], path[i + 1]);

718:             { // scope to avoid stack too deep errors

718:             { // scope to avoid stack too deep errors

725:             address to = i &lt; path.length - 2 ? SoyFinanceLibrary.pairFor(factory, output, path[i + 2]) : _to;

725:             address to = i &lt; path.length - 2 ? SoyFinanceLibrary.pairFor(factory, output, path[i + 2]) : _to;

739:         uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);

742:             IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin,

762:         uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);

765:             IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin,

781:         require(path[path.length - 1] == WETH, &#39;SoyFinanceRouter: INVALID_PATH&#39;);
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

22:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

22:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

22:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

22:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

22:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

22:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

22:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

22:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

22:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

138:         uint256 c = a + b;

170:         uint256 c = a - b;

193:         uint256 c = a * b;

194:         require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

229:         uint256 c = a / b;

350:       return functionCall(target, data, &quot;Address: low-level call failed&quot;);

375:         return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);

390:         require(isContract(target), &quot;Address: call to non-contract&quot;);

910:         require(nonce == nonces[signatory]++, &quot;SOY::delegateBySig: invalid nonce&quot;);

910:         require(nonce == nonces[signatory]++, &quot;SOY::delegateBySig: invalid nonce&quot;);

926:         return nCheckpoints &gt; 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;

949:         if (checkpoints[account][nCheckpoints - 1].fromBlock &lt;= blockNumber) {

950:             return checkpoints[account][nCheckpoints - 1].votes;

959:         uint32 upper = nCheckpoints - 1;

961:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow

961:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow

961:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow

961:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow

961:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow

968:                 upper = center - 1;

978:         uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SOYs (not scaled);

978:         uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SOYs (not scaled);

991:                 uint256 srcRepOld = srcRepNum &gt; 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;

999:                 uint256 dstRepOld = dstRepNum &gt; 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;

1016:         if (nCheckpoints &gt; 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {

1017:             checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;

1020:             numCheckpoints[delegatee] = nCheckpoints + 1;

1027:         require(n &lt; 2**32, errorMessage);

1027:         require(n &lt; 2**32, errorMessage);
</code></pre>
            <pre class="solidity"><code>File: Old/StakingRewards.sol

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

31:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);

59:         uint256 c = a + b;

76:         uint256 c = a - b;

98:         uint256 c = a * b;

99:         require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

118:         uint256 c = a / b;

321:             &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;

321:             &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;

351:         require(address(token).isContract(), &quot;SafeERC20: call to non-contract&quot;);

355:         require(success, &quot;SafeERC20: low-level call failed&quot;);

357:         if (returndata.length &gt; 0) { // Return data is optional

357:         if (returndata.length &gt; 0) { // Return data is optional

394:         _guardCounter += 1;
</code></pre>
            <pre class="solidity"><code>File: Old/WCLO.sol

35:         balanceOf[msg.sender] += msg.value;

40:         balanceOf[msg.sender] -= wad;

65:         if (src != msg.sender &amp;&amp; allowance[src][msg.sender] != uint(-1)) {

67:             allowance[src][msg.sender] -= wad;

70:         balanceOf[src] -= wad;

71:         balanceOf[dst] += wad;

84:  Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;

84:  Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;

84:  Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;

96: share and change all versions of a program--to make sure it remains free

96: share and change all versions of a program--to make sure it remains free

122: giving you legal permission to copy, distribute and/or modify it.

143: software on general-purpose computers, but in those that do, we wish to

146: patents cannot be used to render the program non-free.

157:   &quot;Copyright&quot; also means copyright-like laws that apply to other kinds of

195: for making modifications to it.  &quot;Object code&quot; means any non-source

218: System Libraries, or general-purpose tools or generally available free

259:   3. Protecting Users&#39; Legal Rights From Anti-Circumvention Law.

281: non-permissive terms added in accord with section 7 apply to the code;

325:   6. Conveying Non-Source Forms.

329: machine-readable Corresponding Source under the terms of this License,

368:     e) Convey the object code using peer-to-peer transmission, provided

368:     e) Convey the object code using peer-to-peer transmission, provided

387: commercial, industrial or non-consumer uses, unless such uses represent

468:   All other non-permissive additional terms are considered &quot;further

483:   Additional terms, permissive or non-permissive, may be stated in the

519: occurring solely as a consequence of using peer-to-peer transmission

519: occurring solely as a consequence of using peer-to-peer transmission

547: (including a cross-claim or counterclaim in a lawsuit) alleging that

567:   Each contributor grants you a non-exclusive, worldwide, royalty-free

567:   Each contributor grants you a non-exclusive, worldwide, royalty-free

603: conditioned on the non-exercise of one or more of the rights that are

645:   The Free Software Foundation may publish revised and/or new versions of

673: HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY

683: WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS

717:     This program is free software: you can redistribute it and/or modify

728:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

728:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

728:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

728:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

747: &lt;http://www.gnu.org/licenses/&gt;.

747: &lt;http://www.gnu.org/licenses/&gt;.

747: &lt;http://www.gnu.org/licenses/&gt;.

747: &lt;http://www.gnu.org/licenses/&gt;.

754: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

754: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

754: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

754: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

754: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

754: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

128:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

128:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

128:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

128:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

132:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

132:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

132:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

132:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

136:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

136:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

136:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

136:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

136:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

145:     string public constant symbol = &#39;SOY-LP&#39;;

222:         if (allowance[from][msg.sender] != uint(-1)) {

235:                 keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))

235:                 keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))

255:             uint x = y / 2 + 1;

255:             uint x = y / 2 + 1;

258:                 x = (y / x + x) / 2;

258:                 x = (y / x + x) / 2;

258:                 x = (y / x + x) / 2;

271:     uint224 constant Q112 = 2**112;

271:     uint224 constant Q112 = 2**112;

275:         z = uint224(y) * Q112; // never overflows

275:         z = uint224(y) * Q112; // never overflows

275:         z = uint224(y) * Q112; // never overflows

280:         z = x / uint224(y);

293:     uint public constant MINIMUM_LIQUIDITY = 10**3;

293:     uint public constant MINIMUM_LIQUIDITY = 10**3;

300:     uint112 private reserve0;           // uses single storage slot, accessible via getReserves

300:     uint112 private reserve0;           // uses single storage slot, accessible via getReserves

301:     uint112 private reserve1;           // uses single storage slot, accessible via getReserves

301:     uint112 private reserve1;           // uses single storage slot, accessible via getReserves

302:     uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves

302:     uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves

306:     uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event

306:     uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event

306:     uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event

345:         require(msg.sender == factory, &#39;SoyFinance: FORBIDDEN&#39;); // sufficient check

345:         require(msg.sender == factory, &#39;SoyFinance: FORBIDDEN&#39;); // sufficient check

352:         require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#39;SoyFinance: OVERFLOW&#39;);

352:         require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#39;SoyFinance: OVERFLOW&#39;);

353:         uint32 blockTimestamp = uint32(block.timestamp % 2**32);

353:         uint32 blockTimestamp = uint32(block.timestamp % 2**32);

354:         uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired

354:         uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired

354:         uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired

357:             price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;

357:             price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;

358:             price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;

358:             price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;

370:         uint _kLast = kLast; // gas savings

370:         uint _kLast = kLast; // gas savings

378:                     uint liquidity = numerator / denominator;

389:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

389:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

396:         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

396:         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

399:            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens

399:            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens

401:             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);

401:             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);

407:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

407:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

407:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

407:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

413:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

413:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

414:         address _token0 = token0;                                // gas savings

414:         address _token0 = token0;                                // gas savings

415:         address _token1 = token1;                                // gas savings

415:         address _token1 = token1;                                // gas savings

421:         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

421:         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee

422:         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution

422:         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution

422:         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution

422:         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution

423:         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution

423:         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution

423:         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution

423:         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution

432:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

432:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

432:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

432:         if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date

439:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

439:         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings

444:         { // scope for _token{0,1}, avoids stack too deep errors

444:         { // scope for _token{0,1}, avoids stack too deep errors

448:         if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens

448:         if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens

449:         if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens

449:         if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens

454:         uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;

454:         uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;

454:         uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;

455:         uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;

455:         uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;

455:         uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;

457:         { // scope for reserve{0,1}Adjusted, avoids stack too deep errors

457:         { // scope for reserve{0,1}Adjusted, avoids stack too deep errors

460:         require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#39;SoyFinance: K&#39;);

460:         require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#39;SoyFinance: K&#39;);

469:         address _token0 = token0; // gas savings

469:         address _token0 = token0; // gas savings

470:         address _token1 = token1; // gas savings

470:         address _token1 = token1; // gas savings

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

481:     function tokenReceived(address /*_from*/, uint /*_value*/, bytes calldata /*_data*/) external view {

516:         require(getPair[token0][token1] == address(0), &#39;SoyFinance: PAIR_EXISTS&#39;); // single check is sufficient

516:         require(getPair[token0][token1] == address(0), &#39;SoyFinance: PAIR_EXISTS&#39;); // single check is sufficient

524:         getPair[token1][token0] = pair; // populate mapping in the reverse direction

524:         getPair[token1][token0] = pair; // populate mapping in the reverse direction
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

235:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

235:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

235:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

235:         require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);

239:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

239:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

239:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

239:         require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);

243:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

243:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

243:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

243:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

243:         require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);

264:                 hex&#39;e410ea0a25ce340e309f2f0fe9d58d787bb87dd63d02333e8a9a747230f61758&#39; // init code hash

264:                 hex&#39;e410ea0a25ce340e309f2f0fe9d58d787bb87dd63d02333e8a9a747230f61758&#39; // init code hash

280:         amountB = amountA.mul(reserveB) / reserveA;

290:         amountOut = numerator / denominator;

299:         amountIn = (numerator / denominator).add(1);

307:         for (uint i; i &lt; path.length - 1; i++) {

307:         for (uint i; i &lt; path.length - 1; i++) {

307:         for (uint i; i &lt; path.length - 1; i++) {

308:             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);

309:             amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);

317:         amounts[amounts.length - 1] = amountOut;

318:         for (uint i = path.length - 1; i &gt; 0; i--) {

318:         for (uint i = path.length - 1; i &gt; 0; i--) {

318:         for (uint i = path.length - 1; i &gt; 0; i--) {

319:             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);

320:             amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);

352:     mapping(address =&gt; mapping(address =&gt; uint)) public balanceERC223;    // user =&gt; token =&gt; value

352:     mapping(address =&gt; mapping(address =&gt; uint)) public balanceERC223;    // user =&gt; token =&gt; value

353:     address public msgSender;   // ERC223 sender

353:     address public msgSender;   // ERC223 sender

354:     address public tokenAddress; // ERC223 token address

354:     address public tokenAddress; // ERC223 token address

375:         balanceERC223[_from][msg.sender] = balanceERC223[_from][msg.sender] + _value;   // add token to user balance

375:         balanceERC223[_from][msg.sender] = balanceERC223[_from][msg.sender] + _value;   // add token to user balance

375:         balanceERC223[_from][msg.sender] = balanceERC223[_from][msg.sender] + _value;   // add token to user balance

376:         if (_data.length &gt;= 36) { // signature + at least 1 parameter

376:         if (_data.length &gt;= 36) { // signature + at least 1 parameter

376:         if (_data.length &gt;= 36) { // signature + at least 1 parameter

388:         balanceERC223[msg.sender][token] = userBalance - amount;

399:         if (balance &gt;= amount) { // ERC223 tokens were transferred 

399:         if (balance &gt;= amount) { // ERC223 tokens were transferred 

401:             if (balance &gt; amount) rest = balance - amount;

403:             if (rest != 0) TransferHelper.safeTransfer(token, sender, rest); // refund rest of tokens to sender

403:             if (rest != 0) TransferHelper.safeTransfer(token, sender, rest); // refund rest of tokens to sender

405:         } else if (msg.sender != address(this)) {   // not ERC223 callback

405:         } else if (msg.sender != address(this)) {   // not ERC223 callback

413:         assert(msg.sender == WCLO); // only accept CLO via fallback from the WCLO contract

413:         assert(msg.sender == WCLO); // only accept CLO via fallback from the WCLO contract

484:         if (msg.value &gt; amountCLO) TransferHelper.safeTransferCLO(msg.sender, msg.value - amountCLO);

498:         transferTo(pair, pair, liquidity); // send liquidity to pair

498:         transferTo(pair, pair, liquidity); // send liquidity to pair

539:         uint value = approveMax ? uint(-1) : liquidity;

553:         uint value = approveMax ? uint(-1) : liquidity;

590:         uint value = approveMax ? uint(-1) : liquidity;

600:         for (uint i; i &lt; path.length - 1; i++) {

600:         for (uint i; i &lt; path.length - 1; i++) {

600:         for (uint i; i &lt; path.length - 1; i++) {

601:             (address input, address output) = (path[i], path[i + 1]);

603:             uint amountOut = amounts[i + 1];

605:             address to = i &lt; path.length - 2 ? SoyFinanceLibrary.pairFor(factory, output, path[i + 2]) : _to;

605:             address to = i &lt; path.length - 2 ? SoyFinanceLibrary.pairFor(factory, output, path[i + 2]) : _to;

610:         emit Swap(tx.origin, path[0], path[path.length - 1], amounts[0], amounts[amounts.length - 1]);

610:         emit Swap(tx.origin, path[0], path[path.length - 1], amounts[0], amounts[amounts.length - 1]);

620:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

651:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

663:         require(path[path.length - 1] == WCLO, &#39;SoyFinanceRouter: INVALID_PATH&#39;);

670:         IWCLO(WCLO).withdraw(amounts[amounts.length - 1]);

671:         TransferHelper.safeTransferCLO(to, amounts[amounts.length - 1]);

680:         require(path[path.length - 1] == WCLO, &#39;SoyFinanceRouter: INVALID_PATH&#39;);

682:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

687:         IWCLO(WCLO).withdraw(amounts[amounts.length - 1]);

688:         TransferHelper.safeTransferCLO(to, amounts[amounts.length - 1]);

706:         if (msg.value &gt; amounts[0]) TransferHelper.safeTransferCLO(msg.sender, msg.value - amounts[0]);

712:         for (uint i; i &lt; path.length - 1; i++) {

712:         for (uint i; i &lt; path.length - 1; i++) {

712:         for (uint i; i &lt; path.length - 1; i++) {

713:             (address input, address output) = (path[i], path[i + 1]);

718:             { // scope to avoid stack too deep errors

718:             { // scope to avoid stack too deep errors

725:             address to = i &lt; path.length - 2 ? SoyFinanceLibrary.pairFor(factory, output, path[i + 2]) : _to;

725:             address to = i &lt; path.length - 2 ? SoyFinanceLibrary.pairFor(factory, output, path[i + 2]) : _to;

740:         uint balanceBefore = IERC223(path[path.length - 1]).balanceOf(to);

742:         uint amountOut = IERC223(path[path.length - 1]).balanceOf(to).sub(balanceBefore);

747:         emit Swap(tx.origin, path[0], path[path.length - 1], amountIn, amountOut);

767:         uint balanceBefore = IERC223(path[path.length - 1]).balanceOf(to);

769:         uint amountOut = IERC223(path[path.length - 1]).balanceOf(to).sub(balanceBefore);

774:         emit Swap(tx.origin, path[0], path[path.length - 1], amountIn, amountOut);

789:         require(path[path.length - 1] == WCLO, &#39;SoyFinanceRouter: INVALID_PATH&#39;);

798:         emit Swap(tx.origin, path[0], path[path.length - 1], amountIn, amountOut);
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

32:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

32:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

32:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

32:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

32:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

32:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

32:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

32:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

32:         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

209:       return functionCall(target, data, &quot;Address: low-level call failed&quot;);

234:         return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);

249:         require(isContract(target), &quot;Address: call to non-contract&quot;);

435:         _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);

452:         _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);

471:         _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);

495:         _balances[sender] = _balances[sender] - amount;

496:         _balances[recipient] = _balances[recipient] + amount;

512:         _balances[sender] = _balances[sender] - amount;

513:         _balances[recipient] = _balances[recipient] + amount;

531:         _totalSupply += amount;

532:         _balances[account] += amount;

552:         _balances[account] -= amount;

553:         _totalSupply -= amount;

728:         _mint(msg.sender, 120000000 * 10 ** 18);

728:         _mint(msg.sender, 120000000 * 10 ** 18);

728:         _mint(msg.sender, 120000000 * 10 ** 18);

729:         _moveDelegates(address(0), _delegates[msg.sender], 120000000 * 10 ** 18);

729:         _moveDelegates(address(0), _delegates[msg.sender], 120000000 * 10 ** 18);

729:         _moveDelegates(address(0), _delegates[msg.sender], 120000000 * 10 ** 18);

811:         require(nonce == nonces[signatory]++, &quot;SOY::delegateBySig: invalid nonce&quot;);

811:         require(nonce == nonces[signatory]++, &quot;SOY::delegateBySig: invalid nonce&quot;);

827:         return nCheckpoints &gt; 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;

850:         if (checkpoints[account][nCheckpoints - 1].fromBlock &lt;= blockNumber) {

851:             return checkpoints[account][nCheckpoints - 1].votes;

860:         uint32 upper = nCheckpoints - 1;

862:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow

862:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow

862:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow

862:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow

862:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow

869:                 upper = center - 1;

879:         uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SOYs (not scaled);

879:         uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SOYs (not scaled);

892:                 uint256 srcRepOld = srcRepNum &gt; 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;

893:                 uint256 srcRepNew = srcRepOld - amount;

900:                 uint256 dstRepOld = dstRepNum &gt; 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;

901:                 uint256 dstRepNew = dstRepOld + amount;

917:         if (nCheckpoints &gt; 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {

918:             checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;

921:             numCheckpoints[delegatee] = nCheckpoints + 1;

928:         require(n &lt; 2**32, errorMessage);

928:         require(n &lt; 2**32, errorMessage);
</code></pre>
            <pre class="solidity"><code>File: Staking/GobalStaking.sol

124:         address _rewardsToken,      // SOY token

124:         address _rewardsToken,      // SOY token

125:         address _lpToken            // LP token that will be staked in this Local Farm

125:         address _lpToken            // LP token that will be staked in this Local Farm

156:     uint256 public paymentDelay = 1 days;          // DEFAULTS_TO 1 days

156:     uint256 public paymentDelay = 1 days;          // DEFAULTS_TO 1 days

159:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1

159:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1

161:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

161:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

161:     mapping(address =&gt; uint256)   public localFarmId;     // locals farm address =&gt; id; localFarm at ID = 0 is considered non-existing

170:         return (block.timestamp / paymentDelay) * paymentDelay + paymentDelay;

170:         return (block.timestamp / paymentDelay) * paymentDelay + paymentDelay;

170:         return (block.timestamp / paymentDelay) * paymentDelay + paymentDelay;

175:         return localFarms[localFarmId[_farm]].lastPayment + paymentDelay &lt;= next_payment();

180:         return 1000 * localFarms[localFarmId[_farm]].multiplier / totalMultipliers;

180:         return 1000 * localFarms[localFarmId[_farm]].multiplier / totalMultipliers;

187:         return rewardPerSecond * allocationX1000 / 1000;

187:         return rewardPerSecond * allocationX1000 / 1000;

199:         address _localFarmAddress,            // staking contract

199:         address _localFarmAddress,            // staking contract

206:         lastAddedFarmIndex++;

206:         lastAddedFarmIndex++;

210:         localFarms[lastAddedFarmIndex].lastPayment = next_payment() - paymentDelay;

214:         totalMultipliers += uint256(_multiplier);

228:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

228:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

228:         totalMultipliers = totalMultipliers - uint256(localFarms[localFarmId[_localFarmAddress]].multiplier); // update totalMultipliers

233:         localFarms[localFarmId[_localFarmAddress]].multiplier   = 0; // Not critically important, can be removed for gas efficiency reasons.

233:         localFarms[localFarmId[_localFarmAddress]].multiplier   = 0; // Not critically important, can be removed for gas efficiency reasons.

234:         localFarms[localFarmId[_localFarmAddress]].lastPayment  = 0; // Not critically important, can be removed for gas efficiency reasons.

234:         localFarms[localFarmId[_localFarmAddress]].lastPayment  = 0; // Not critically important, can be removed for gas efficiency reasons.

246:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

246:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

246:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

246:         totalMultipliers = totalMultipliers + uint256(_multiplier) - uint256(oldMultiplier); // update totalMultipliers

256:         if(localFarms[localFarmId[_localFarmAddress]].lastPayment + paymentDelay &gt; next_payment())

265:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;

265:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;

265:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;

265:             uint256 _reward = (next_payment() - localFarms[localFarmId[_localFarmAddress]].lastPayment) * getRewardPerSecond() * getAllocationX1000(_localFarmAddress) / 1000;
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

13:     uint c = a * b;

14:     require(c / a == b);

20:     uint c = a / b;

27:     return a - b;

31:     uint c = a + b;

89:         uint time;              // Staking start time or last claim rewards

89:         uint time;              // Staking start time or last claim rewards

90:         uint multiplier;        // Rewards multiplier = 0.40 + (0.05 * rounds). [0.45..1] (max rounds 12)

90:         uint multiplier;        // Rewards multiplier = 0.40 + (0.05 * rounds). [0.45..1] (max rounds 12)

90:         uint multiplier;        // Rewards multiplier = 0.40 + (0.05 * rounds). [0.45..1] (max rounds 12)

90:         uint multiplier;        // Rewards multiplier = 0.40 + (0.05 * rounds). [0.45..1] (max rounds 12)

91:         uint end_time;          // Time when staking ends and user may withdraw. After this time user will not receive rewards.

91:         uint end_time;          // Time when staking ends and user may withdraw. After this time user will not receive rewards.

96:     uint public Timestamp = now;    //timestamp of the last interaction with the contract.

96:     uint public Timestamp = now;    //timestamp of the last interaction with the contract.

98:     uint public TotalStakingWeight; //total weight = sum (each_staking_amount * each_staking_time).

98:     uint public TotalStakingWeight; //total weight = sum (each_staking_amount * each_staking_time).

98:     uint public TotalStakingWeight; //total weight = sum (each_staking_amount * each_staking_time).

99:     uint public TotalStakingAmount; //currently frozen amount for Staking.

99:     uint public TotalStakingAmount; //currently frozen amount for Staking.

100:     uint public StakingRewardPool;  //available amount for paying rewards.

100:     uint public StakingRewardPool;  //available amount for paying rewards.

103:     uint public constant round_interval   = 27 days;     // 1 month.

103:     uint public constant round_interval   = 27 days;     // 1 month.

104:     uint public constant max_delay        = 365 days;    // 1 year after staking ends.

104:     uint public constant max_delay        = 365 days;    // 1 year after staking ends.

107:     uint constant NOMINATOR = 10**18;           // Nominator / denominator used for float point numbers

107:     uint constant NOMINATOR = 10**18;           // Nominator / denominator used for float point numbers

107:     uint constant NOMINATOR = 10**18;           // Nominator / denominator used for float point numbers

107:     uint constant NOMINATOR = 10**18;           // Nominator / denominator used for float point numbers

107:     uint constant NOMINATOR = 10**18;           // Nominator / denominator used for float point numbers

111:     uint public stake_until = 1662033600; // 1 September 2022 12:00:00 GMT (all staking should be finished until this time)

111:     uint public stake_until = 1662033600; // 1 September 2022 12:00:00 GMT (all staking should be finished until this time)

112:     address public admin;   // admin address who can set stake_until

112:     address public admin;   // admin address who can set stake_until

142:         if (_from == globalFarm || _from == admin) return; // if globalFarm or admin transfer tokens, they will be added to reward pool

142:         if (_from == globalFarm || _from == admin) return; // if globalFarm or admin transfer tokens, they will be added to reward pool

150:             rounds = abi.decode(_data, (uint256));  // _data should contain ABI encoded UINT =  number of rounds

150:             rounds = abi.decode(_data, (uint256));  // _data should contain ABI encoded UINT =  number of rounds

169:         if (block.number &gt; LastBlock)   //run once per block.

169:         if (block.number &gt; LastBlock)   //run once per block.

175:             StakingRewardPool = IERC223(SOY).balanceOf(address(this)).sub(TotalStakingAmount + amount);   //fix rewards pool for this block.

175:             StakingRewardPool = IERC223(SOY).balanceOf(address(this)).sub(TotalStakingAmount + amount);   //fix rewards pool for this block.

175:             StakingRewardPool = IERC223(SOY).balanceOf(address(this)).sub(TotalStakingAmount + amount);   //fix rewards pool for this block.

179:             if (now &gt; Timestamp) //But with this condition I feel safer :) May be removed.

179:             if (now &gt; Timestamp) //But with this condition I feel safer :) May be removed.

181:                 uint _blocks = block.number - _LastBlock;

182:                 uint _seconds = now - Timestamp;

183:                 if (_seconds &gt; _blocks * 25) //if time goes far in the future, then use new time as 25 second * blocks.

183:                 if (_seconds &gt; _blocks * 25) //if time goes far in the future, then use new time as 25 second * blocks.

183:                 if (_seconds &gt; _blocks * 25) //if time goes far in the future, then use new time as 25 second * blocks.

183:                 if (_seconds &gt; _blocks * 25) //if time goes far in the future, then use new time as 25 second * blocks.

185:                     _seconds = _blocks * 25;

187:                 TotalStakingWeight += _seconds.mul(TotalStakingAmount);

188:                 Timestamp += _seconds;

197:         new_block(amount); //run once per block.

197:         new_block(amount); //run once per block.

203:         uint multiplier = (40 + (10 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

203:         uint multiplier = (40 + (10 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

203:         uint multiplier = (40 + (10 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

203:         uint multiplier = (40 + (10 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

203:         uint multiplier = (40 + (10 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

203:         uint multiplier = (40 + (10 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

203:         uint multiplier = (40 + (10 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

203:         uint multiplier = (40 + (10 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

205:         require(end_time &lt;= stake_until, &quot;Too long staking time&quot;);  // do not allow stake longer than &quot;stake_until&quot;

205:         require(end_time &lt;= stake_until, &quot;Too long staking time&quot;);  // do not allow stake longer than &quot;stake_until&quot;

209:             if (_Timestamp &gt;= staker[user].time + round_interval)

215:                 end_time = staker_end_time;     // Staking end time is the bigger from previous and new one.

215:                 end_time = staker_end_time;     // Staking end time is the bigger from previous and new one.

216:                 r = (end_time.sub(_Timestamp)).div(round_interval);  // update number of rounds

216:                 r = (end_time.sub(_Timestamp)).div(round_interval);  // update number of rounds

218:                 multiplier = (40 + (5 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

218:                 multiplier = (40 + (5 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

218:                 multiplier = (40 + (5 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

218:                 multiplier = (40 + (5 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

218:                 multiplier = (40 + (5 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

218:                 multiplier = (40 + (5 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

218:                 multiplier = (40 + (5 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

218:                 multiplier = (40 + (5 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

223:                 multiplier = ((staker[user].multiplier.mul(staker_amount)).add(multiplier.mul(amount))) / (staker_amount.add(amount));

224:                 if (multiplier &gt; NOMINATOR) multiplier = NOMINATOR; // multiplier can&#39;t be more then 1

224:                 if (multiplier &gt; NOMINATOR) multiplier = NOMINATOR; // multiplier can&#39;t be more then 1

226:             TotalStakingWeight = TotalStakingWeight.sub((_Timestamp.sub(staker[user].time)).mul(staker_amount)); // remove from Weight

226:             TotalStakingWeight = TotalStakingWeight.sub((_Timestamp.sub(staker[user].time)).mul(staker_amount)); // remove from Weight

254:         new_block(0); //run once per block.

254:         new_block(0); //run once per block.

255:         require(Timestamp &gt;= staker[user].end_time); //reject withdrawal before end time.

255:         require(Timestamp &gt;= staker[user].end_time); //reject withdrawal before end time.

262:         TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[user].time)).mul(staker[user].amount)); // remove from Weight.

262:         TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[user].time)).mul(staker[user].amount)); // remove from Weight.

278:         new_block(0); //run once per block

278:         new_block(0); //run once per block

281:         if (_Timestamp &gt; staker[user].end_time) _Timestamp = staker[user].end_time; // rewards calculates until staking ends

281:         if (_Timestamp &gt; staker[user].end_time) _Timestamp = staker[user].end_time; // rewards calculates until staking ends

282:         uint _StakingInterval = _Timestamp.sub(staker[user].time);  //time interval of deposit.

282:         uint _StakingInterval = _Timestamp.sub(staker[user].time);  //time interval of deposit.

285:             uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval); //only complete rounds.

285:             uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval); //only complete rounds.

285:             uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval); //only complete rounds.

286:             uint _StakerWeight = _CompleteRoundsInterval.mul(staker[user].amount); //Weight of completed rounds.

286:             uint _StakerWeight = _CompleteRoundsInterval.mul(staker[user].amount); //Weight of completed rounds.

287:             uint _reward = StakingRewardPool.mul(_StakerWeight).div(TotalStakingWeight);  //StakingRewardPool * _StakerWeight/TotalStakingWeight

287:             uint _reward = StakingRewardPool.mul(_StakerWeight).div(TotalStakingWeight);  //StakingRewardPool * _StakerWeight/TotalStakingWeight

287:             uint _reward = StakingRewardPool.mul(_StakerWeight).div(TotalStakingWeight);  //StakingRewardPool * _StakerWeight/TotalStakingWeight

287:             uint _reward = StakingRewardPool.mul(_StakerWeight).div(TotalStakingWeight);  //StakingRewardPool * _StakerWeight/TotalStakingWeight

288:             _reward = _reward.mul(staker[user].multiplier) / NOMINATOR;   // reduce rewards if staked on less then 12 rounds.

288:             _reward = _reward.mul(staker[user].multiplier) / NOMINATOR;   // reduce rewards if staked on less then 12 rounds.

288:             _reward = _reward.mul(staker[user].multiplier) / NOMINATOR;   // reduce rewards if staked on less then 12 rounds.

290:             TotalStakingWeight = TotalStakingWeight.sub(_StakerWeight); // remove paid Weight.

290:             TotalStakingWeight = TotalStakingWeight.sub(_StakerWeight); // remove paid Weight.

292:             staker[user].time = staker[user].time.add(_CompleteRoundsInterval); // reset to paid time, staking continue without a loss of incomplete rounds.

292:             staker[user].time = staker[user].time.add(_CompleteRoundsInterval); // reset to paid time, staking continue without a loss of incomplete rounds.

304:         uint _blocks = block.number - LastBlock;

305:         uint _seconds = now - Timestamp;

306:         if (_seconds &gt; _blocks * 25) //if time goes far in the future, then use new time as 25 second * blocks.

306:         if (_seconds &gt; _blocks * 25) //if time goes far in the future, then use new time as 25 second * blocks.

306:         if (_seconds &gt; _blocks * 25) //if time goes far in the future, then use new time as 25 second * blocks.

306:         if (_seconds &gt; _blocks * 25) //if time goes far in the future, then use new time as 25 second * blocks.

308:             _seconds = _blocks * 25;

310:         uint _Timestamp = Timestamp + _seconds;

311:         if (_Timestamp &gt; staker[_addr].end_time) _Timestamp = staker[_addr].end_time; // rewards calculates until staking ends

311:         if (_Timestamp &gt; staker[_addr].end_time) _Timestamp = staker[_addr].end_time; // rewards calculates until staking ends

312:         uint _TotalStakingWeight = TotalStakingWeight + _seconds.mul(TotalStakingAmount);

313:         uint _StakingInterval = _Timestamp.sub(staker[_addr].time); //time interval of deposit.

313:         uint _StakingInterval = _Timestamp.sub(staker[_addr].time); //time interval of deposit.

316:         uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval); //only complete rounds.

316:         uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval); //only complete rounds.

316:         uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval); //only complete rounds.

317:         uint _StakerWeight = _CompleteRoundsInterval.mul(staker[_addr].amount); //Weight of completed rounds.

317:         uint _StakerWeight = _CompleteRoundsInterval.mul(staker[_addr].amount); //Weight of completed rounds.

319:         _reward = _StakingRewardPool.mul(_StakerWeight).div(_TotalStakingWeight);  //StakingRewardPool * _StakerWeight/TotalStakingWeight

319:         _reward = _StakingRewardPool.mul(_StakerWeight).div(_TotalStakingWeight);  //StakingRewardPool * _StakerWeight/TotalStakingWeight

319:         _reward = _StakingRewardPool.mul(_StakerWeight).div(_TotalStakingWeight);  //StakingRewardPool * _StakerWeight/TotalStakingWeight

319:         _reward = _StakingRewardPool.mul(_StakerWeight).div(_TotalStakingWeight);  //StakingRewardPool * _StakerWeight/TotalStakingWeight

320:         _reward = _reward.mul(staker[_addr].multiplier) / NOMINATOR;   // reduce rewards if staked on less then 12 rounds.

320:         _reward = _reward.mul(staker[_addr].multiplier) / NOMINATOR;   // reduce rewards if staked on less then 12 rounds.

320:         _reward = _reward.mul(staker[_addr].multiplier) / NOMINATOR;   // reduce rewards if staked on less then 12 rounds.

339:         new_block(0); //run once per block.

339:         new_block(0); //run once per block.

345:         TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[_addr].time)).mul(_amount)); // remove from Weight.

345:         TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[_addr].time)).mul(_amount)); // remove from Weight.
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

110:     address public constant globalFarm = 0xBEefd9072712552c6dBde1bd1851699Bf2e1916f; // GlobalStaking contract

110:     address public constant globalFarm = 0xBEefd9072712552c6dBde1bd1851699Bf2e1916f; // GlobalStaking contract

111:     uint256 public constant TIME_RESOLUTION = 1 hours;  // rewards calculates per each TIME_RESOLUTION

111:     uint256 public constant TIME_RESOLUTION = 1 hours;  // rewards calculates per each TIME_RESOLUTION

112:     uint256 public constant BONUS_LIMIT = 10;   // maximum bonus percentage can be bought

112:     uint256 public constant BONUS_LIMIT = 10;   // maximum bonus percentage can be bought

113:     address public bonusToken;  // token address 

113:     address public bonusToken;  // token address 

114:     uint256[] internal bonusPrice;    // bonus percentage = index + 1 (i.e. 1% = index 0), value price in bonusToken (from lower to higher)

114:     uint256[] internal bonusPrice;    // bonus percentage = index + 1 (i.e. 1% = index 0), value price in bonusToken (from lower to higher)

114:     uint256[] internal bonusPrice;    // bonus percentage = index + 1 (i.e. 1% = index 0), value price in bonusToken (from lower to higher)

126:     uint256 public totalShares; // effective total shares included bonuses

126:     uint256 public totalShares; // effective total shares included bonuses

127:     uint256 public totalStaked; // total staked amount on contract

127:     uint256 public totalStaked; // total staked amount on contract

132:         uint64 endTime; // Time when staking ends and user may withdraw. After this time user will not receive rewards.

132:         uint64 endTime; // Time when staking ends and user may withdraw. After this time user will not receive rewards.

133:         uint64 index; // Balances indexed

133:         uint64 index; // Balances indexed

134:         uint64 bonus;   // percent of bonus applied

134:         uint64 bonus;   // percent of bonus applied

135:         uint32 affiliatePercent; // percent of user&#39;s rewards that will be transferred to affiliate, i.e. 5% 

135:         uint32 affiliatePercent; // percent of user&#39;s rewards that will be transferred to affiliate, i.e. 5% 

136:         uint32 noAffiliatePercent; // percent of user&#39;s rewards will be paid if no affiliate.

136:         uint32 noAffiliatePercent; // percent of user&#39;s rewards will be paid if no affiliate.

137:         address affiliate; // address of affiliate

137:         address affiliate; // address of affiliate

142:         uint256 atTime; // time when reduce balance

142:         uint256 atTime; // time when reduce balance

143:         uint256 balanceReduceOrRewardPerShare; // amount to reduce balance or reward per share at time

143:         uint256 balanceReduceOrRewardPerShare; // amount to reduce balance or reward per share at time

148:     uint256 public startIndex; // start index of unprocessed balances records

148:     uint256 public startIndex; // start index of unprocessed balances records

151:     uint256 public lockTime; // in seconds, time that tokens should be locked when user call unlock()

151:     uint256 public lockTime; // in seconds, time that tokens should be locked when user call unlock()

152:     uint256 public affiliatePercent; // percent of user&#39;s rewards that will be transferred to affiliate, i.e. 5% 

152:     uint256 public affiliatePercent; // percent of user&#39;s rewards that will be transferred to affiliate, i.e. 5% 

153:     uint256 public noAffiliatePercent; // percent of user&#39;s rewards will be paid if no affiliate. 

153:     uint256 public noAffiliatePercent; // percent of user&#39;s rewards will be paid if no affiliate. 

157:     uint256 private unsplitReward;  // Reward that should be split on next TIME_RESOLUTION round

157:     uint256 private unsplitReward;  // Reward that should be split on next TIME_RESOLUTION round

182:         noAffiliatePercent = 100;   // by default 100% rewards go to users

182:         noAffiliatePercent = 100;   // by default 100% rewards go to users

183:         IERC223(SOY_TOKEN).approve(address(this), type(uint256).max); // allow contract to use transferFrom instead of transfer

183:         IERC223(SOY_TOKEN).approve(address(this), type(uint256).max); // allow contract to use transferFrom instead of transfer

211:             bonus = abi.decode(_data, (uint256));  // _data should contain ABI encoded UINT =  bonus percentage

211:             bonus = abi.decode(_data, (uint256));  // _data should contain ABI encoded UINT =  bonus percentage

216:         if (_from == globalFarm || _from == owner()) return; // if globalFarm or admin transfer tokens, they will be added to reward pool

216:         if (_from == globalFarm || _from == owner()) return; // if globalFarm or admin transfer tokens, they will be added to reward pool

218:         if (_data.length == 32) _affiliate = abi.decode(_data, (address)); // _data should contain ABI encoded affiliate address 

218:         if (_data.length == 32) _affiliate = abi.decode(_data, (address)); // _data should contain ABI encoded affiliate address 

230:                 _withdraw(user); // withdraw if lock expired

230:                 _withdraw(user); // withdraw if lock expired

237:         if (affiliate != address(0) &amp;&amp; staker[user].affiliate == address(0)) { // if affiliate was not set before

237:         if (affiliate != address(0) &amp;&amp; staker[user].affiliate == address(0)) { // if affiliate was not set before

242:         if (staker[user].amount == 0) staker[user].noAffiliatePercent = uint32(noAffiliatePercent); // first deposit

242:         if (staker[user].amount == 0) staker[user].noAffiliatePercent = uint32(noAffiliatePercent); // first deposit

243:         totalStaked += amount;

244:         totalShares += (amount * (100 + staker[user].bonus) / 100); // multiply staked amount by bonus multiplier

244:         totalShares += (amount * (100 + staker[user].bonus) / 100); // multiply staked amount by bonus multiplier

244:         totalShares += (amount * (100 + staker[user].bonus) / 100); // multiply staked amount by bonus multiplier

244:         totalShares += (amount * (100 + staker[user].bonus) / 100); // multiply staked amount by bonus multiplier

244:         totalShares += (amount * (100 + staker[user].bonus) / 100); // multiply staked amount by bonus multiplier

244:         totalShares += (amount * (100 + staker[user].bonus) / 100); // multiply staked amount by bonus multiplier

246:         staker[user].amount += amount;

250:         IERC223(SOY_TOKEN).transfer(user, userReward); // transfer rewards to user

250:         IERC223(SOY_TOKEN).transfer(user, userReward); // transfer rewards to user

256:         uint256 _alignedTime = (block.timestamp / TIME_RESOLUTION) * TIME_RESOLUTION; // aligned by 1 hour

256:         uint256 _alignedTime = (block.timestamp / TIME_RESOLUTION) * TIME_RESOLUTION; // aligned by 1 hour

256:         uint256 _alignedTime = (block.timestamp / TIME_RESOLUTION) * TIME_RESOLUTION; // aligned by 1 hour

256:         uint256 _alignedTime = (block.timestamp / TIME_RESOLUTION) * TIME_RESOLUTION; // aligned by 1 hour

267:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

267:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

267:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

267:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

267:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

267:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

270:         uint256 _reward = getRewardPerSecond() * getAllocationX1000() * 1e15; // 1e15 = 1e18 / 1000;

270:         uint256 _reward = getRewardPerSecond() * getAllocationX1000() * 1e15; // 1e15 = 1e18 / 1000;

270:         uint256 _reward = getRewardPerSecond() * getAllocationX1000() * 1e15; // 1e15 = 1e18 / 1000;

270:         uint256 _reward = getRewardPerSecond() * getAllocationX1000() * 1e15; // 1e15 = 1e18 / 1000;

270:         uint256 _reward = getRewardPerSecond() * getAllocationX1000() * 1e15; // 1e15 = 1e18 / 1000;

272:         uint256 i = startIndex; // start from

272:         uint256 i = startIndex; // start from

274:         for (; i &lt; maxRecords; i++) {

274:         for (; i &lt; maxRecords; i++) {

275:             if (balances[i].atTime &gt; _alignedTime) break; // future record

275:             if (balances[i].atTime &gt; _alignedTime) break; // future record

276:             timePassed = balances[i].atTime - _lastRewardTimestamp;

279:                 _accumulatedRewardPerShare +

280:                 ((timePassed * _reward) / _totalShares);

280:                 ((timePassed * _reward) / _totalShares);

282:                 _totalShares -

290:         timePassed = _alignedTime - _lastRewardTimestamp;

293:                 _accumulatedRewardPerShare +

294:                 ((timePassed * _reward) / _totalShares);

294:                 ((timePassed * _reward) / _totalShares);

302:         uint256 shares = staker[user].amount * (100 + staker[user].bonus) / 100;

302:         uint256 shares = staker[user].amount * (100 + staker[user].bonus) / 100;

302:         uint256 shares = staker[user].amount * (100 + staker[user].bonus) / 100;

308:         uint256 reward = (shares * (_accumulatedRewardPerShare - staker[user].rewardPerSharePaid)) / 1e18; // total reward

308:         uint256 reward = (shares * (_accumulatedRewardPerShare - staker[user].rewardPerSharePaid)) / 1e18; // total reward

308:         uint256 reward = (shares * (_accumulatedRewardPerShare - staker[user].rewardPerSharePaid)) / 1e18; // total reward

308:         uint256 reward = (shares * (_accumulatedRewardPerShare - staker[user].rewardPerSharePaid)) / 1e18; // total reward

308:         uint256 reward = (shares * (_accumulatedRewardPerShare - staker[user].rewardPerSharePaid)) / 1e18; // total reward

309:         if (staker[user].affiliate == address(0)) { // no affiliate

309:         if (staker[user].affiliate == address(0)) { // no affiliate

311:             if (_noAffiliatePercent &lt; noAffiliatePercent) _noAffiliatePercent = noAffiliatePercent; // use better noAffiliatePercent for user

311:             if (_noAffiliatePercent &lt; noAffiliatePercent) _noAffiliatePercent = noAffiliatePercent; // use better noAffiliatePercent for user

312:             userReward = reward * _noAffiliatePercent / 100;

312:             userReward = reward * _noAffiliatePercent / 100;

313:             affiliateRewardOrRest = reward - userReward;    // rest of rewards that should be added to rewards pool. 

313:             affiliateRewardOrRest = reward - userReward;    // rest of rewards that should be added to rewards pool. 

313:             affiliateRewardOrRest = reward - userReward;    // rest of rewards that should be added to rewards pool. 

315:             affiliateRewardOrRest = reward * staker[user].affiliatePercent / 100; // affiliate reward

315:             affiliateRewardOrRest = reward * staker[user].affiliatePercent / 100; // affiliate reward

315:             affiliateRewardOrRest = reward * staker[user].affiliatePercent / 100; // affiliate reward

315:             affiliateRewardOrRest = reward * staker[user].affiliatePercent / 100; // affiliate reward

316:             userReward = reward - affiliateRewardOrRest;

323:         uint256 _alignedTime = (block.timestamp / TIME_RESOLUTION) * TIME_RESOLUTION; // aligned by 1 hour

323:         uint256 _alignedTime = (block.timestamp / TIME_RESOLUTION) * TIME_RESOLUTION; // aligned by 1 hour

323:         uint256 _alignedTime = (block.timestamp / TIME_RESOLUTION) * TIME_RESOLUTION; // aligned by 1 hour

323:         uint256 _alignedTime = (block.timestamp / TIME_RESOLUTION) * TIME_RESOLUTION; // aligned by 1 hour

334:         uint256 _reward = getRewardPerSecond() * getAllocationX1000() * 1e15; // 1e15 = 1e18 / 1000;

334:         uint256 _reward = getRewardPerSecond() * getAllocationX1000() * 1e15; // 1e15 = 1e18 / 1000;

334:         uint256 _reward = getRewardPerSecond() * getAllocationX1000() * 1e15; // 1e15 = 1e18 / 1000;

334:         uint256 _reward = getRewardPerSecond() * getAllocationX1000() * 1e15; // 1e15 = 1e18 / 1000;

334:         uint256 _reward = getRewardPerSecond() * getAllocationX1000() * 1e15; // 1e15 = 1e18 / 1000;

339:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

339:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

339:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

339:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

339:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

339:             _accumulatedRewardPerShare += ((_unsplitReward-1) * 1e18 / _totalShares); // split the unsplitReward among shareholders

340:             unsplitReward = 1;  // use 1 instead of 0 to save gas

340:             unsplitReward = 1;  // use 1 instead of 0 to save gas

344:         uint256 i = startIndex; // start from

344:         uint256 i = startIndex; // start from

345:         maxRecords = maxRecords + i; // last record

345:         maxRecords = maxRecords + i; // last record

345:         maxRecords = maxRecords + i; // last record

348:         for (; i &lt; maxRecords; i++) {

348:         for (; i &lt; maxRecords; i++) {

349:             if (balances[i].atTime &gt; _alignedTime) break; // future record

349:             if (balances[i].atTime &gt; _alignedTime) break; // future record

350:             timePassed = balances[i].atTime - _lastRewardTimestamp;

353:                 _accumulatedRewardPerShare +

354:                 ((timePassed * _reward) / _totalShares);

354:                 ((timePassed * _reward) / _totalShares);

356:                 _totalShares -

359:                 .balanceReduceOrRewardPerShare = _accumulatedRewardPerShare; // using the same variable reduce gas usage by 15K

359:                 .balanceReduceOrRewardPerShare = _accumulatedRewardPerShare; // using the same variable reduce gas usage by 15K

363:         timePassed = _alignedTime - _lastRewardTimestamp;

367:                 _accumulatedRewardPerShare +

368:                 ((timePassed * _reward) / _totalShares);

368:                 ((timePassed * _reward) / _totalShares);

383:         uint256 endTime = ((block.timestamp + lockTime) / TIME_RESOLUTION) * TIME_RESOLUTION; // staking end time aligned by 1 hour

383:         uint256 endTime = ((block.timestamp + lockTime) / TIME_RESOLUTION) * TIME_RESOLUTION; // staking end time aligned by 1 hour

383:         uint256 endTime = ((block.timestamp + lockTime) / TIME_RESOLUTION) * TIME_RESOLUTION; // staking end time aligned by 1 hour

383:         uint256 endTime = ((block.timestamp + lockTime) / TIME_RESOLUTION) * TIME_RESOLUTION; // staking end time aligned by 1 hour

383:         uint256 endTime = ((block.timestamp + lockTime) / TIME_RESOLUTION) * TIME_RESOLUTION; // staking end time aligned by 1 hour

386:         uint256 bonus = staker[msg.sender].bonus * stakedAmount / 100;

386:         uint256 bonus = staker[msg.sender].bonus * stakedAmount / 100;

387:         stakedAmount = stakedAmount + bonus; // effective share = staked amount + bonus

387:         stakedAmount = stakedAmount + bonus; // effective share = staked amount + bonus

387:         stakedAmount = stakedAmount + bonus; // effective share = staked amount + bonus

387:         stakedAmount = stakedAmount + bonus; // effective share = staked amount + bonus

388:         if (balances.length != 0 &amp;&amp; balances[balances.length - 1].atTime == endTime) {

390:             balances[balances.length - 1]

391:                 .balanceReduceOrRewardPerShare += stakedAmount;

395:         staker[msg.sender].index = uint64(balances.length - 1);

416:         totalStaked -= amount;

420:         IERC223(SOY_TOKEN).transfer(user, amount + userReward);

436:         uint256 amount = getBonusPrice(bonus, user);  // get difference in price between current and wanted bonuses

436:         uint256 amount = getBonusPrice(bonus, user);  // get difference in price between current and wanted bonuses

444:         _safeBurn(amount);   // burn bonus token

444:         _safeBurn(amount);   // burn bonus token

446:         uint256 bonusShares = (bonus - staker[user].bonus) * staker[user].amount / 100; // just bought bonus * staking amount

446:         uint256 bonusShares = (bonus - staker[user].bonus) * staker[user].amount / 100; // just bought bonus * staking amount

446:         uint256 bonusShares = (bonus - staker[user].bonus) * staker[user].amount / 100; // just bought bonus * staking amount

446:         uint256 bonusShares = (bonus - staker[user].bonus) * staker[user].amount / 100; // just bought bonus * staking amount

446:         uint256 bonusShares = (bonus - staker[user].bonus) * staker[user].amount / 100; // just bought bonus * staking amount

446:         uint256 bonusShares = (bonus - staker[user].bonus) * staker[user].amount / 100; // just bought bonus * staking amount

447:         totalShares += bonusShares;

451:         IERC223(SOY_TOKEN).transfer(user, userReward); // transfer rewards to user

451:         IERC223(SOY_TOKEN).transfer(user, userReward); // transfer rewards to user

455:         try IERC223(bonusToken).burn(amount) returns (bool)   // try to burn bonus token

455:         try IERC223(bonusToken).burn(amount) returns (bool)   // try to burn bonus token

474:                 IERC223(SOY_TOKEN).transferFrom(address(this), affiliate, affiliateRewardOrRest); // transfer rewards to user

474:                 IERC223(SOY_TOKEN).transferFrom(address(this), affiliate, affiliateRewardOrRest); // transfer rewards to user

476:                 unsplitReward += affiliateRewardOrRest; // split rest reward on next update round 

476:                 unsplitReward += affiliateRewardOrRest; // split rest reward on next update round 

476:                 unsplitReward += affiliateRewardOrRest; // split rest reward on next update round 

486:         if(bonus &lt;= userBonus) return 0; // user already has this or better bonus

486:         if(bonus &lt;= userBonus) return 0; // user already has this or better bonus

487:         if (userBonus != 0) alreadyPaid = bonusPrice[userBonus-1];   // 1% = index 0, 2% = index 1, ...

487:         if (userBonus != 0) alreadyPaid = bonusPrice[userBonus-1];   // 1% = index 0, 2% = index 1, ...

487:         if (userBonus != 0) alreadyPaid = bonusPrice[userBonus-1];   // 1% = index 0, 2% = index 1, ...

488:         amount = bonusPrice[bonus-1] - alreadyPaid;

488:         amount = bonusPrice[bonus-1] - alreadyPaid;

522:         if (_token == SOY_TOKEN &amp;&amp; totalStaked != 0) return;   // allow rescue SOY tokens when no stake

522:         if (_token == SOY_TOKEN &amp;&amp; totalStaked != 0) return;   // allow rescue SOY tokens when no stake
</code></pre>
            <pre class="solidity"><code>File: Vesting.sol

152:     mapping(address =&gt; bool) public depositors; // address of users who has right to deposit and allocate tokens

152:     mapping(address =&gt; bool) public depositors; // address of users who has right to deposit and allocate tokens

177:         uint256 amount;             // amount of token

177:         uint256 amount;             // amount of token

178:         uint256 unlockPercentage;   // percentage of initially unlocked token

178:         uint256 unlockPercentage;   // percentage of initially unlocked token

179:         uint256 startVesting;       // Timestamp (unix time) when starts vesting. First vesting will be at this time

179:         uint256 startVesting;       // Timestamp (unix time) when starts vesting. First vesting will be at this time

180:         uint256 vestingPercentage;  // percentage of tokens will be unlocked every interval (i.e. 10% per 30 days)

180:         uint256 vestingPercentage;  // percentage of tokens will be unlocked every interval (i.e. 10% per 30 days)

181:         uint256 vestingInterval;    // interval (in seconds) of vesting (i.e. 30 days)        

181:         uint256 vestingInterval;    // interval (in seconds) of vesting (i.e. 30 days)        

186:     mapping(address =&gt; Allocation[]) public beneficiaries; // beneficiary =&gt; Allocation

186:     mapping(address =&gt; Allocation[]) public beneficiaries; // beneficiary =&gt; Allocation

187:     mapping(address =&gt; uint256) public claimedAmount;   // beneficiary =&gt; already claimed amount

187:     mapping(address =&gt; uint256) public claimedAmount;   // beneficiary =&gt; already claimed amount

192:         address indexed to,         // beneficiary of tokens

192:         address indexed to,         // beneficiary of tokens

193:         uint256 amount,             // amount of token

193:         uint256 amount,             // amount of token

194:         uint256 unlockPercentage,   // percentage of initially unlocked token

194:         uint256 unlockPercentage,   // percentage of initially unlocked token

195:         uint256 startVesting,       // Timestamp (unix time) when starts vesting. First vesting will be at this time

195:         uint256 startVesting,       // Timestamp (unix time) when starts vesting. First vesting will be at this time

196:         uint256 vestingPercentage,  // percentage of tokens will be unlocked every interval (i.e. 10% per 30 days)

196:         uint256 vestingPercentage,  // percentage of tokens will be unlocked every interval (i.e. 10% per 30 days)

197:         uint256 vestingInterval     // interval (in seconds) of vesting (i.e. 30 days)        

197:         uint256 vestingInterval     // interval (in seconds) of vesting (i.e. 30 days)        

212:         address to, // beneficiary of tokens

212:         address to, // beneficiary of tokens

213:         uint256 amount, // amount of token

213:         uint256 amount, // amount of token

214:         uint256 unlockPercentage,   // percentage of initially unlocked token

214:         uint256 unlockPercentage,   // percentage of initially unlocked token

215:         uint256 startVesting,       // Timestamp (unix time) when starts vesting. First vesting will be at this time

215:         uint256 startVesting,       // Timestamp (unix time) when starts vesting. First vesting will be at this time

216:         uint256 vestingPercentage,  // percentage of tokens will be unlocked every interval (i.e. 10% per 30 days)

216:         uint256 vestingPercentage,  // percentage of tokens will be unlocked every interval (i.e. 10% per 30 days)

217:         uint256 vestingInterval     // interval (in seconds) of vesting (i.e. 30 days)

217:         uint256 vestingInterval     // interval (in seconds) of vesting (i.e. 30 days)

225:         totalAllocated += amount;

242:         claimedAmount[beneficiary] += unlockedAmount;

243:         totalClaimed += unlockedAmount;

249:         for (uint256 i = 0; i &lt; beneficiaries[beneficiary].length; i++) {

249:         for (uint256 i = 0; i &lt; beneficiaries[beneficiary].length; i++) {

252:             uint256 unlocked = amount * b.unlockPercentage / 100;

252:             uint256 unlocked = amount * b.unlockPercentage / 100;

254:                 uint256 intervals = (block.timestamp - b.startVesting) / b.vestingInterval + 1;

254:                 uint256 intervals = (block.timestamp - b.startVesting) / b.vestingInterval + 1;

254:                 uint256 intervals = (block.timestamp - b.startVesting) / b.vestingInterval + 1;

255:                 unlocked = unlocked + (amount * intervals * b.vestingPercentage / 100);

255:                 unlocked = unlocked + (amount * intervals * b.vestingPercentage / 100);

255:                 unlocked = unlocked + (amount * intervals * b.vestingPercentage / 100);

255:                 unlocked = unlocked + (amount * intervals * b.vestingPercentage / 100);

258:             unlockedAmount += unlocked;

260:         unlockedAmount = unlockedAmount - claimedAmount[beneficiary];

265:         uint256 unclaimed = totalAllocated - totalClaimed;

266:         amount = amount - unclaimed;
</code></pre>
            <pre class="solidity"><code>File: WCLO.sol

67:         balanceOf[msg.sender] += msg.value;

71:         balanceOf[msg.sender] -= wad;

110:         if (src != msg.sender &amp;&amp; allowance[src][msg.sender] != uint(int(-1))) {

111:             allowance[src][msg.sender] -= wad;

114:         balanceOf[src] -= wad;

115:         balanceOf[dst] += wad;

122:     function tokenReceived(address _from, uint _value, bytes memory /*_data*/) external {

122:     function tokenReceived(address _from, uint _value, bytes memory /*_data*/) external {

122:     function tokenReceived(address _from, uint _value, bytes memory /*_data*/) external {

122:     function tokenReceived(address _from, uint _value, bytes memory /*_data*/) external {

125:         balanceOf[_from] -= _value;

136:  Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;

136:  Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;

136:  Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;

148: share and change all versions of a program--to make sure it remains free

148: share and change all versions of a program--to make sure it remains free

174: giving you legal permission to copy, distribute and/or modify it.

195: software on general-purpose computers, but in those that do, we wish to

198: patents cannot be used to render the program non-free.

209:   &quot;Copyright&quot; also means copyright-like laws that apply to other kinds of

247: for making modifications to it.  &quot;Object code&quot; means any non-source

270: System Libraries, or general-purpose tools or generally available free

311:   3. Protecting Users&#39; Legal Rights From Anti-Circumvention Law.

333: non-permissive terms added in accord with section 7 apply to the code;

377:   6. Conveying Non-Source Forms.

381: machine-readable Corresponding Source under the terms of this License,

420:     e) Convey the object code using peer-to-peer transmission, provided

420:     e) Convey the object code using peer-to-peer transmission, provided

439: commercial, industrial or non-consumer uses, unless such uses represent

520:   All other non-permissive additional terms are considered &quot;further

535:   Additional terms, permissive or non-permissive, may be stated in the

571: occurring solely as a consequence of using peer-to-peer transmission

571: occurring solely as a consequence of using peer-to-peer transmission

599: (including a cross-claim or counterclaim in a lawsuit) alleging that

619:   Each contributor grants you a non-exclusive, worldwide, royalty-free

619:   Each contributor grants you a non-exclusive, worldwide, royalty-free

655: conditioned on the non-exercise of one or more of the rights that are

697:   The Free Software Foundation may publish revised and/or new versions of

725: HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY

735: WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS

769:     This program is free software: you can redistribute it and/or modify

780:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

780:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

780:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

780:     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

799: &lt;http://www.gnu.org/licenses/&gt;.

799: &lt;http://www.gnu.org/licenses/&gt;.

799: &lt;http://www.gnu.org/licenses/&gt;.

799: &lt;http://www.gnu.org/licenses/&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.

806: &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

4: import &quot;./Ownable.sol&quot;;

15:     mapping (address =&gt; mapping(address =&gt; bool)) public isReceived; // token =&gt; user =&gt; isReceived

15:     mapping (address =&gt; mapping(address =&gt; bool)) public isReceived; // token =&gt; user =&gt; isReceived

16:     mapping (address =&gt; uint256) public dropAmount; // token =&gt; amount of token to drop

16:     mapping (address =&gt; uint256) public dropAmount; // token =&gt; amount of token to drop

42:         for (uint i = 0; i &lt; recipients.length; i++) {

42:         for (uint i = 0; i &lt; recipients.length; i++) {

50:         for (uint i = 0; i &lt; recipients.length; i++) {

50:         for (uint i = 0; i &lt; recipients.length; i++) {
</code></pre>
            <h3 id="gas-9-use-custom-errors"><a name="GAS-9"></a>[GAS-9] Use
                Custom
                Errors</h3>
            <p><a
                    href="https://blog.soliditylang.org/2021/04/21/custom-errors/">Source</a>
                Instead of using error strings, to reduce deployment and runtime
                cost,
                you should use Custom Errors. This would save both deployment
                and
                runtime cost.</p>
            <p><em>Instances (316)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

40:         require(owner() == msg.sender, &quot;Ownable: caller is not the owner&quot;);

61:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

189:         require(system == msg.sender, &quot;Ownable: caller is not the owner&quot;);

229:         require(participants[airdropId][day].totalParticipants == 0, &quot;Day already closed&quot;);

241:         require(airdrops[airdropId].daysPassed + 1 == day, &quot;Day already passed&quot;);

242:         require(airdrops[airdropId].daysPassed &lt; airdrops[airdropId].duration, &quot;Airdrop ended&quot;);
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYGlobalFarmSimplified.sol

39:         require(isOwner(),&quot;Not Owner&quot;);

74:         require(newOwner != address(0),&quot;Zero address not allowed&quot;);

281:         require(instance != address(0), &quot;ERC1167: create failed&quot;);
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYLocalFarm.sol

47:         require(localCounter == _guardCounter, &quot;ReentrancyGuard: reentrant call&quot;);

57:         require(msg.sender == globalFarm, &quot;Caller is not global Farm contract&quot;);

106:         require(owner() == msg.sender, &quot;Not Owner&quot;);

121:         require(globalFarm == address(0), &quot;Already initialized&quot;);

131:         require(active, &quot;The farm is not enabled by owner!&quot;);

145:         require(msg.sender == address(lpToken), &quot;Trying to deposit wrong token&quot;);

223:         require(user.amount &gt;= _amount, &quot;withdraw: not good&quot;);

251:         require(!ISimplifiedGlobalFarm(globalFarm).farmExists(address(this)), &quot;Farm must not be active&quot;);

275:         require(token != address(rewardsToken), &quot;Reward token is not prone to ERC20 issues&quot;);

276:         require(token != address(lpToken), &quot;LP token is not prone to ERC20 issues&quot;);
</code></pre>
            <pre class="solidity"><code>File: BTTC/WBTT.sol

123:         require(msg.sender == address(this), &quot;Only when transfer WBTT&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/Initializable.sol

47:         require(_initializing || !_initialized, &quot;Initializable: contract is already initialized&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/LocalToBridge.sol

49:         require(msg.sender == soy &amp;&amp; _from == globalFarm, &quot;sender is not allowed&quot;);

60:         require(ISimplifiedGlobalFarm(globalFarm).rewardMintingAvailable(address(this)), &quot;Reward not available&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarm.sol

74:         require(value &gt; 0, &quot;Counter: decrement overflow&quot;);

162:         require(isOwner(),&quot;Not Owner&quot;);

197:         require(newOwner != address(0),&quot;Zero address not allowed&quot;);

314:         require(snapshotId &gt; 0, &quot;Snapshot id is 0&quot;);

315:         require(snapshotId &lt;= getCurrentSnapshotId(), &quot;Nonexistent id&quot;);

407:         require(localFarmId[_localFarmAddress] == 0,  &quot;LocalFarm with this address already exists&quot;);

433:         require(localFarmId[_localFarmAddress] == 0,  &quot;LocalFarm with this address already exists&quot;);

434:         require(_id != 0,  &quot;LocalFarm at address 0 is considered non-existing by system&quot;);

435:         require(_id &lt; lastAddedFarmIndex, &quot;Can not add farms ahead of autoincremented index&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarmSimplified.sol

39:         require(isOwner(),&quot;Not Owner&quot;);

74:         require(newOwner != address(0),&quot;Zero address not allowed&quot;);

148:         require(localFarmId[_localFarmAddress] == 0,  &quot;LocalFarm with this address already exists&quot;);

167:         require(localFarmId[_localFarmAddress] == 0,  &quot;LocalFarm with this address already exists&quot;);

168:         require(_id != 0,  &quot;LocalFarm at address 0 is considered non-existing by system&quot;);

169:         require(_id &lt; lastAddedFarmIndex, &quot;Can not add farms ahead of autoincremented index&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

137:         require(localCounter == _guardCounter, &quot;ReentrancyGuard: reentrant call&quot;);

147:         require(msg.sender == globalFarm, &quot;Caller is not global Farm contract&quot;);

197:         require(isOwner(),&quot;Not Owner&quot;);

232:         require(newOwner != address(0),&quot;Zero address not allowed&quot;);

283:         require(active, &quot;The farm is not enabled by owner!&quot;);

297:         require(msg.sender == address(lpToken), &quot;Trying to deposit wrong token&quot;);

376:         require(user.amount &gt;= _amount, &quot;withdraw: not good&quot;);

404:         require(!ISimplifiedGlobalFarm(globalFarm).farmExists(address(this)), &quot;Farm must not be active&quot;);

428:         require(token != address(rewardsToken), &quot;Reward token is not prone to ERC20 issues&quot;);

429:         require(token != address(lpToken), &quot;LP token is not prone to ERC20 issues&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

140:         require(localCounter == _guardCounter, &quot;ReentrancyGuard: reentrant call&quot;);

166:         require(msg.sender == rewardsDistribution, &quot;Caller is not RewardsDistribution contract&quot;);

213:         require(msg.sender == address(stakingToken), &quot;Wrong token deposit reverted&quot;);

214:         require(_amount &gt; 0, &quot;Cannot stake 0&quot;);

225:         require(amount &gt; 0, &quot;Cannot stake 0&quot;);

239:         require(amount &gt; 0, &quot;Cannot stake 0&quot;);

280:         require(amount &gt; 0, &quot;Cannot withdraw 0&quot;);

323:         require(rewardRate &lt;= balance / rewardsDuration, &quot;Provided reward is too high&quot;);
</code></pre>
            <pre class="solidity"><code>File: IDO/UpgradeableProxyFlattened.sol

137:         require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);

141:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

198:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

199:         require(isContract(target), &quot;Address: call to non-contract&quot;);

223:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

315:         require(Address.isContract(newImplementation), &quot;UpgradeableProxy: new implementation is not a contract&quot;);

417:         require(newAdmin != address(0), &quot;TransparentUpgradeableProxy: new admin is the zero address&quot;);
</code></pre>
            <pre class="solidity"><code>File: IDO/ido.sol

40:         require(owner() == msg.sender, &quot;Ownable: caller is not the owner&quot;);

49:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

179:         require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);

245:         require(!isPaused, &quot;Paused&quot;);

250:         require(_owner == address(0), &quot;Already initialized&quot;);

276:         require(_bank != address(0), &quot;Zero address not allowed&quot;);

323:         require(totalSoyToSell &gt;= totalSoySold, &quot;Wrong amount&quot;);

330:         require(currentRoundId == 0, &quot;Only start once&quot;);

331:         require(totalSoyToSell != 0, &quot;No SOY to sell&quot;);

347:         require(fromRound &lt; toRound &amp;&amp; toRound &lt;= currentRoundId, &quot;Incorrect rounds parameters&quot;);

475:         require(allowedToken[msg.sender], &quot;Token isn&#39;t allowed&quot;);

485:         require(allowedToken[token], &quot;Token isn&#39;t allowed&quot;);

487:             require(amount == msg.value, &quot;Incorrect CLO amount&quot;);

489:             require(msg.value == 0, &quot;Only token&quot;);

525:         require(currentRoundId &lt;= auctionRounds, &quot;All rounds completed&quot;);

563:         require(round.start &lt;= block.timestamp, &quot;Auction is not started yet&quot;);

564:         require(currentRoundId &lt;= auctionRounds, &quot;Auction is finished&quot;);

565:         require(round.soyToSell != 0, &quot;No SOY to sell&quot;);

609:         require(currentRoundId &gt; auctionRounds, &quot;Auction is not finished&quot;);

611:         require(amountAvailable != 0, &quot;No Soy to burn&quot;);

620:                 require(bets[i][newWallet].usdValue == 0 &amp;&amp; bets[i][newWallet].soyAmount == 0, &quot;newWallet already in use&quot;);
</code></pre>
            <pre class="solidity"><code>File: IDO/priceFeed.sol

40:         require(owner() == msg.sender, &quot;Ownable: caller is not the owner&quot;);

61:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

75:         require(msg.sender == system || msg.sender == owner(), &quot;Only system or owner&quot;);

88:         require(price != 0, &quot;Incorrect price&quot;);

99:         require(token.length == price.length, &quot;Incorrect length&quot;);
</code></pre>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

73:         require(owner() == _msgSender(), &quot;Ownable: caller is not the owner&quot;);

94:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

150:         require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);

300:         require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);

304:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

374:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

375:         require(isContract(target), &quot;Address: call to non-contract&quot;);

403:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

431:         require(isContract(target), &quot;Address: delegate call to non-contract&quot;);

534:             require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);

555:             require(abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);

729:         require(!_isContract(msg.sender), &quot;Contract not allowed&quot;);

730:         require(msg.sender == tx.origin, &quot;Proxy contract not allowed&quot;);

735:         require(msg.sender == operatorAddress, &quot;Not operator&quot;);

740:         require((msg.sender == owner()) || (msg.sender == injectorAddress), &quot;Not owner or injector&quot;);

792:         require(_ticketNumbers.length != 0, &quot;No ticket specified&quot;);

793:         require(_ticketNumbers.length &lt;= maxNumberTicketsPerBuyOrClaim, &quot;Too many tickets&quot;);

795:         require(_lotteries[_lotteryId].status == Status.Open, &quot;Lottery is not open&quot;);

796:         require(block.timestamp &lt; _lotteries[_lotteryId].endTime, &quot;Lottery is over&quot;);

814:             require((thisTicketNumber &gt;= 1000000) &amp;&amp; (thisTicketNumber &lt;= 1999999), &quot;Outside range&quot;);

846:         require(_ticketIds.length == _brackets.length, &quot;Not same length&quot;);

847:         require(_ticketIds.length != 0, &quot;Length must be &gt;0&quot;);

848:         require(_ticketIds.length &lt;= maxNumberTicketsPerBuyOrClaim, &quot;Too many tickets&quot;);

849:         require(_lotteries[_lotteryId].status == Status.Claimable, &quot;Lottery not claimable&quot;);

855:             require(_brackets[i] &lt; 6, &quot;Bracket out of range&quot;); // Must be between 0 and 5

859:             require(_lotteries[_lotteryId].firstTicketIdNextLottery &gt; thisTicketId, &quot;TicketId too high&quot;);

860:             require(_lotteries[_lotteryId].firstTicketId &lt;= thisTicketId, &quot;TicketId too low&quot;);

861:             require(msg.sender == _tickets[thisTicketId].owner, &quot;Not the owner&quot;);

869:             require(rewardForTicketId != 0, &quot;No prize for this bracket&quot;);

894:         require(_lotteries[_lotteryId].status == Status.Open, &quot;Lottery not open&quot;);

895:         require(block.timestamp &gt; _lotteries[_lotteryId].endTime, &quot;Lottery not over&quot;);

918:         require(_lotteries[_lotteryId].status == Status.Close, &quot;Lottery not close&quot;);

919:         require(_lotteryId == randomGenerator.viewLatestLotteryId(), &quot;Numbers not drawn&quot;);

995:         require(_lotteries[currentLotteryId].status == Status.Claimable, &quot;Lottery not in claimable&quot;);

1017:         require(_lotteries[_lotteryId].status == Status.Open, &quot;Lottery not open&quot;);

1056:         require(_discountDivisor &gt;= MIN_DISCOUNT_DIVISOR, &quot;Discount divisor too low&quot;);

1057:         require(_treasuryFee &lt;= MAX_TREASURY_FEE, &quot;Treasury fee too high&quot;);

1106:         require(_tokenAddress != address(cakeToken), &quot;Cannot be CAKE token&quot;);

1123:         require(_minPriceTicketInCake &lt;= _maxPriceTicketInCake, &quot;minPrice must be &lt; maxPrice&quot;);

1134:         require(_maxNumberTicketsPerBuy != 0, &quot;Must be &gt; 0&quot;);

1150:         require(_operatorAddress != address(0), &quot;Cannot be zero address&quot;);

1151:         require(_treasuryAddress != address(0), &quot;Cannot be zero address&quot;);

1152:         require(_injectorAddress != address(0), &quot;Cannot be zero address&quot;);

1172:         require(_discountDivisor &gt;= MIN_DISCOUNT_DIVISOR, &quot;Must be &gt;= MIN_DISCOUNT_DIVISOR&quot;);

1173:         require(_numberTickets != 0, &quot;Number of tickets must be &gt; 0&quot;);
</code></pre>
            <pre class="solidity"><code>File: Lottery/RandomNumberGenerator.sol

73:         require(owner() == _msgSender(), &quot;Ownable: caller is not the owner&quot;);

94:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

237:         require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);

241:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

311:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

312:         require(isContract(target), &quot;Address: call to non-contract&quot;);

340:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

368:         require(isContract(target), &quot;Address: delegate call to non-contract&quot;);

471:             require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);

492:             require(abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);

761:         require(msg.sender == vrfCoordinator, &quot;Only VRFCoordinator can fulfill&quot;);

890:         require(msg.sender == pancakeSwapLottery, &quot;Only PancakeSwapLottery&quot;);

891:         require(keyHash != bytes32(0), &quot;Must have valid key hash&quot;);

892:         require(LINK.balanceOf(address(this)) &gt;= fee, &quot;Not enough LINK tokens&quot;);

949:         require(latestRequestId == requestId, &quot;Wrong requestId&quot;);
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

73:         require(owner() == _msgSender(), &quot;Ownable: caller is not the owner&quot;);

94:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

150:         require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);

300:         require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);

304:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

374:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

375:         require(isContract(target), &quot;Address: call to non-contract&quot;);

403:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

431:         require(isContract(target), &quot;Address: delegate call to non-contract&quot;);

534:             require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);

555:             require(abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);

730:         require(!_isContract(msg.sender), &quot;Contract not allowed&quot;);

731:         require(msg.sender == tx.origin, &quot;Proxy contract not allowed&quot;);

736:         require(msg.sender == operatorAddress, &quot;Not operator&quot;);

741:         require((msg.sender == owner()) || (msg.sender == injectorAddress), &quot;Not owner or injector&quot;);

793:         require(_ticketNumbers.length != 0, &quot;No ticket specified&quot;);

794:         require(_ticketNumbers.length &lt;= maxNumberTicketsPerBuyOrClaim, &quot;Too many tickets&quot;);

796:         require(_lotteries[_lotteryId].status == Status.Open, &quot;Lottery is not open&quot;);

797:         require(block.timestamp &lt; _lotteries[_lotteryId].endTime, &quot;Lottery is over&quot;);

816:             require((thisTicketNumber &gt;= 1000) &amp;&amp; (thisTicketNumber &lt;= 1999), &quot;Outside range&quot;);

848:         require(_ticketIds.length == _brackets.length, &quot;Not same length&quot;);

849:         require(_ticketIds.length != 0, &quot;Length must be &gt;0&quot;);

850:         require(_ticketIds.length &lt;= maxNumberTicketsPerBuyOrClaim, &quot;Too many tickets&quot;);

851:         require(_lotteries[_lotteryId].status == Status.Claimable, &quot;Lottery not claimable&quot;);

857:             require(_brackets[i] &lt; MAX_BRACKETS, &quot;Bracket out of range&quot;); // Must be between 0 and 5

861:             require(_lotteries[_lotteryId].firstTicketIdNextLottery &gt; thisTicketId, &quot;TicketId too high&quot;);

862:             require(_lotteries[_lotteryId].firstTicketId &lt;= thisTicketId, &quot;TicketId too low&quot;);

863:             require(msg.sender == _tickets[thisTicketId].owner, &quot;Not the owner&quot;);

871:             require(rewardForTicketId != 0, &quot;No prize for this bracket&quot;);

897:         require(_lotteries[_lotteryId].status == Status.Open, &quot;Lottery not open&quot;);

898:         require(block.timestamp &gt; _lotteries[_lotteryId].endTime, &quot;Lottery not over&quot;);

921:         require(_lotteries[_lotteryId].status == Status.Close, &quot;Lottery not close&quot;);

922:         require(_lotteryId == randomGenerator.viewLatestLotteryId(), &quot;Numbers not drawn&quot;);

998:         require(_lotteries[currentLotteryId].status == Status.Claimable, &quot;Lottery not in claimable&quot;);

1020:         require(_lotteries[_lotteryId].status == Status.Open, &quot;Lottery not open&quot;);

1059:         require(_discountDivisor &gt;= MIN_DISCOUNT_DIVISOR, &quot;Discount divisor too low&quot;);

1060:         require(_treasuryFee &lt;= MAX_TREASURY_FEE, &quot;Treasury fee too high&quot;);

1109:         require(_tokenAddress != address(soyToken), &quot;Cannot be SOY token&quot;);

1126:         require(_minPriceTicketInSoy &lt;= _maxPriceTicketInSoy, &quot;minPrice must be &lt; maxPrice&quot;);

1137:         require(_maxNumberTicketsPerBuy != 0, &quot;Must be &gt; 0&quot;);

1153:         require(_operatorAddress != address(0), &quot;Cannot be zero address&quot;);

1154:         require(_treasuryAddress != address(0), &quot;Cannot be zero address&quot;);

1155:         require(_injectorAddress != address(0), &quot;Cannot be zero address&quot;);

1175:         require(_discountDivisor &gt;= MIN_DISCOUNT_DIVISOR, &quot;Must be &gt;= MIN_DISCOUNT_DIVISOR&quot;);

1176:         require(_numberTickets != 0, &quot;Number of tickets must be &gt; 0&quot;);
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyRandomNumberGenerator.sol

66:         require(owner() == msg.sender, &quot;Ownable: caller is not the owner&quot;);

187:         require(operator == msg.sender, &quot;Only operator&quot;);

201:         require(msg.sender == SoyLottery, &quot;Only SoyLottery&quot;);

212:         require(entropy.commitBlock == 0, &quot;Already committed&quot;);

220:         require(entropy.requestId == requestId, &quot;Wrong requestId&quot;);

221:         require(keccak256(abi.encodePacked(secret)) == entropy.secretHash, &quot;Wrong secret&quot;);

223:         require(commitBlock != 0 &amp;&amp; commitBlock + 1 &lt; block.number, &quot;Reveal not allowed&quot;);  // allow reveal at least in 2 blocks after commitment
</code></pre>
            <pre class="solidity"><code>File: Muticall2.sol

24:             require(success, &quot;Multicall aggregate: call failed&quot;);

61:                 require(success, &quot;Multicall2 aggregate: call failed&quot;);
</code></pre>
            <pre class="solidity"><code>File: Old/CLOE_ERC20.sol

139:     require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);

191:     require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

300:     require(_owner == _msgSender(), &quot;Ownable: caller is not the owner&quot;);

328:     require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

355:     require(gateways[_msgSender()], &quot;Caller is not the gateway&quot;);

528:     require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);

529:     require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);

530:     require(recipient != address(this), &quot;ERC20: transfer to the contract&quot;); 

548:     require(account != address(0), &quot;ERC20: mint to the zero address&quot;);

568:     require(account != address(0), &quot;ERC20: burn from the zero address&quot;);

589:     require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);

590:     require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);
</code></pre>
            <pre class="solidity"><code>File: Old/SOY_ERC20.sol

139:     require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);

191:     require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

300:     require(_owner == _msgSender(), &quot;Ownable: caller is not the owner&quot;);

328:     require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

354:     require(gateways[_msgSender()], &quot;Caller is not the gateway&quot;);

526:     require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);

527:     require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);

528:     require(recipient != address(this), &quot;ERC20: transfer to the contract&quot;); 

546:     require(account != address(0), &quot;ERC20: mint to the zero address&quot;);

565:     require(account != address(0), &quot;ERC20: burn from the zero address&quot;);

586:     require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);

587:     require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

139:         require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);

194:         require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

324:         require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);

328:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

385:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

390:         require(isContract(target), &quot;Address: call to non-contract&quot;);

623:         require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);

624:         require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);

643:         require(account != address(0), &quot;ERC20: mint to the zero address&quot;);

664:         require(account != address(0), &quot;ERC20: burn from the zero address&quot;);

687:         require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);

688:         require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);

765:         require(_owner == _msgSender(), &quot;Ownable: caller is not the owner&quot;);

786:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

909:         require(signatory != address(0), &quot;SOY::delegateBySig: invalid signature&quot;);

910:         require(nonce == nonces[signatory]++, &quot;SOY::delegateBySig: invalid nonce&quot;);

911:         require(now &lt;= expiry, &quot;SOY::delegateBySig: signature expired&quot;);

941:         require(blockNumber &lt; block.number, &quot;SOY::getPriorVotes: not yet determined&quot;);
</code></pre>
            <pre class="solidity"><code>File: Old/StakingRewards.sol

60:         require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);

75:         require(b &lt;= a, &quot;SafeMath: subtraction overflow&quot;);

99:         require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

117:         require(b &gt; 0, &quot;SafeMath: division by zero&quot;);

136:         require(b != 0, &quot;SafeMath: modulo by zero&quot;);

351:         require(address(token).isContract(), &quot;SafeERC20: call to non-contract&quot;);

355:         require(success, &quot;SafeERC20: low-level call failed&quot;);

359:             require(abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);

397:         require(localCounter == _guardCounter, &quot;ReentrancyGuard: reentrant call&quot;);

433:         require(msg.sender == rewardsDistribution, &quot;Caller is not RewardsDistribution contract&quot;);

505:         require(amount &gt; 0, &quot;Cannot stake 0&quot;);

517:         require(amount &gt; 0, &quot;Cannot stake 0&quot;);

525:         require(amount &gt; 0, &quot;Cannot withdraw 0&quot;);

562:         require(rewardRate &lt;= balance.div(rewardsDuration), &quot;Provided reward too high&quot;);
</code></pre>
            <pre class="solidity"><code>File: Ownable.sol

39:         require(isOwner(),&quot;Not Owner&quot;);

74:         require(newOwner != address(0),&quot;Zero address not allowed&quot;);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

482:         require(msg.sender == token0 || msg.sender == token1, &quot;Wrong token&quot;);

487:         require(_token != token0 &amp;&amp; _token != token1, &quot;Wrong token&quot;);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

365:         require(msg.sender != address(this), &quot;ERC223 not accepted&quot;);

380:             require(success, &quot;ERC223 internal call failed&quot;);

387:         require(userBalance &gt;= amount, &quot;Not enough tokens&quot;);

395:             require(token == tokenAddress, &quot;Transfer wrong token&quot;);

408:             revert(&quot;Not enough ERC223 balance&quot;);
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

43:         require(minters[msg.sender], &quot;Only minter is allowed to do this&quot;);

49:         require(setup_mode, &quot;This is only allowed in setup mode&quot;);

183:         require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);

187:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

244:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

249:         require(isContract(target), &quot;Address: call to non-contract&quot;);

490:         require(sender != address(0), &quot;ERC223: transfer from the zero address&quot;);

491:         require(recipient != address(0), &quot;ERC223: transfer to the zero address&quot;);

507:         require(sender != address(0), &quot;ERC223: transfer from the zero address&quot;);

508:         require(recipient != address(0), &quot;ERC223: transfer to the zero address&quot;);

527:         require(account != address(0), &quot;ERC20: mint to the zero address&quot;);

548:         require(account != address(0), &quot;ERC20: burn from the zero address&quot;);

571:         require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);

572:         require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);

639:         require(_owner == _msgSender(), &quot;Ownable: caller is not the owner&quot;);

660:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

810:         require(signatory != address(0), &quot;SOY::delegateBySig: invalid signature&quot;);

811:         require(nonce == nonces[signatory]++, &quot;SOY::delegateBySig: invalid nonce&quot;);

812:         require(block.timestamp &lt;= expiry, &quot;SOY::delegateBySig: signature expired&quot;);

842:         require(blockNumber &lt; block.number, &quot;SOY::getPriorVotes: not yet determined&quot;);
</code></pre>
            <pre class="solidity"><code>File: Staking/GobalStaking.sol

39:         require(isOwner(),&quot;Not Owner&quot;);

74:         require(newOwner != address(0),&quot;Zero address not allowed&quot;);

278:         require(_from == globalFarm, &quot;Only globalFarm&quot;);
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

134:         require(admin == msg.sender, &quot;Only admin&quot;);

141:         require(msg.sender == SOY, &quot;Only SOY&quot;);

205:         require(end_time &lt;= stake_until, &quot;Too long staking time&quot;);  // do not allow stake longer than &quot;stake_until&quot;
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

41:         require(owner() == msg.sender, &quot;Ownable: caller is not the owner&quot;);

50:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

210:             require(_data.length == 32, &quot;Wrong bonus percentage&quot;);

215:         require(msg.sender == SOY_TOKEN, &quot;Only SOY staking is supported&quot;);

227:         require(isEnabled, &quot;staking disabled&quot;);

233:                 require(amount == 0, &quot;Account locked for staking&quot;);

431:         require(staker[user].endTime == 0, &quot;Account locked for staking&quot;);

437:         require(amount != 0, &quot;user already has this bonus&quot;);

443:         require(amount == value, &quot;user transferred wrong amount&quot;);

483:         require(bonus !=0 &amp;&amp; bonus &lt;= bonusPrice.length, &quot;incorrect bonus&quot;);

501:         require(bonusPrices.length &lt;= BONUS_LIMIT, &quot;Too big bonus&quot;);

514:         require(_affiliatePercent &lt;= 50 &amp;&amp; _noAffiliatePercent &gt;= 50 &amp;&amp; _noAffiliatePercent &lt;= 100, &quot;Wrong percentage&quot;);
</code></pre>
            <pre class="solidity"><code>File: Vesting.sol

40:         require(owner() == msg.sender, &quot;Ownable: caller is not the owner&quot;);

61:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

155:         require(depositors[msg.sender], &quot;Only depositors allowed&quot;);

166:         require(depositors[_from], &quot;Only depositors allowed&quot;);

222:         require(amount &lt;= getUnallocatedAmount(), &quot;Not enough tokens&quot;);

223:         require(startVesting &gt; block.timestamp, &quot;startVesting in the past&quot;);

241:         require(unlockedAmount != 0, &quot;No unlocked tokens&quot;);
</code></pre>
            <pre class="solidity"><code>File: WCLO.sol

123:         require(msg.sender == address(this), &quot;Only when transfer WCLO&quot;);
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

34:         require(signer == ecrecover(keccak256(abi.encodePacked(token, msg.sender, dropAmount[token])), v, r, s), &quot;ECDSA signature is not valid.&quot;);

35:         require(!isReceived[token][msg.sender], &quot;Tokens already received&quot;);
</code></pre>
            <h3
                id="gas-10-dont-initialize-variables-with-default-value"><a
                    name="GAS-10"></a>[GAS-10]
                Don't initialize variables with default value</h3>
            <p><em>Instances (30)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

215:         for (uint i = 0; i &lt; len; i++) {

251:         for (uint i = 0; i &lt; users.length; i++) {

266:         for (uint i = 0; i &lt; users.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYGlobalFarmSimplified.sol

113:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYLocalFarm.sol

128:     bool active = false;
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarm.sol

103:         uint256 low = 0;

245:     uint256 public pendingNextSnapshotTimestamp = 0;

249:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarmSimplified.sol

103:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1
</code></pre>
            <pre class="solidity"><code>File: IDO/priceFeed.sol

100:         for (uint i=0; i&lt;token.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

811:         for (uint256 i = 0; i &lt; _ticketNumbers.length; i++) {

854:         for (uint256 i = 0; i &lt; _ticketIds.length; i++) {

936:         for (uint32 i = 0; i &lt; 6; i++) {

1206:         for (uint256 i = 0; i &lt; length; i++) {

1279:         for (uint256 i = 0; i &lt; length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

812:         for (uint256 i = 0; i &lt; _ticketNumbers.length; i++) {

856:         for (uint256 i = 0; i &lt; _ticketIds.length; i++) {

939:         for (uint32 i = 0; i &lt; MAX_BRACKETS; i++) {

1209:         for (uint256 i = 0; i &lt; length; i++) {

1282:         for (uint256 i = 0; i &lt; length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Muticall2.sol

22:         for(uint256 i = 0; i &lt; calls.length; i++) {

57:         for(uint256 i = 0; i &lt; calls.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

958:         uint32 lower = 0;
</code></pre>
            <pre class="solidity"><code>File: Old/StakingRewards.sol

446:     uint256 public periodFinish = 0;

447:     uint256 public rewardRate = 0;
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

859:         uint32 lower = 0;
</code></pre>
            <pre class="solidity"><code>File: Staking/GobalStaking.sol

159:     uint256                       public lastAddedFarmIndex = 0; // Farm IDs will start from 1
</code></pre>
            <pre class="solidity"><code>File: Vesting.sol

249:         for (uint256 i = 0; i &lt; beneficiaries[beneficiary].length; i++) {
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

42:         for (uint i = 0; i &lt; recipients.length; i++) {

50:         for (uint i = 0; i &lt; recipients.length; i++) {
</code></pre>
            <h3 id="gas-11-long-revert-strings"><a name="GAS-11"></a>[GAS-11]
                Long
                revert strings</h3>
            <p><em>Instances (148)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

61:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYLocalFarm.sol

57:         require(msg.sender == globalFarm, &quot;Caller is not global Farm contract&quot;);

131:         require(active, &quot;The farm is not enabled by owner!&quot;);

275:         require(token != address(rewardsToken), &quot;Reward token is not prone to ERC20 issues&quot;);

276:         require(token != address(lpToken), &quot;LP token is not prone to ERC20 issues&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/Initializable.sol

47:         require(_initializing || !_initialized, &quot;Initializable: contract is already initialized&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarm.sol

407:         require(localFarmId[_localFarmAddress] == 0,  &quot;LocalFarm with this address already exists&quot;);

433:         require(localFarmId[_localFarmAddress] == 0,  &quot;LocalFarm with this address already exists&quot;);

434:         require(_id != 0,  &quot;LocalFarm at address 0 is considered non-existing by system&quot;);

435:         require(_id &lt; lastAddedFarmIndex, &quot;Can not add farms ahead of autoincremented index&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarmSimplified.sol

148:         require(localFarmId[_localFarmAddress] == 0,  &quot;LocalFarm with this address already exists&quot;);

167:         require(localFarmId[_localFarmAddress] == 0,  &quot;LocalFarm with this address already exists&quot;);

168:         require(_id != 0,  &quot;LocalFarm at address 0 is considered non-existing by system&quot;);

169:         require(_id &lt; lastAddedFarmIndex, &quot;Can not add farms ahead of autoincremented index&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

147:         require(msg.sender == globalFarm, &quot;Caller is not global Farm contract&quot;);

283:         require(active, &quot;The farm is not enabled by owner!&quot;);

428:         require(token != address(rewardsToken), &quot;Reward token is not prone to ERC20 issues&quot;);

429:         require(token != address(lpToken), &quot;LP token is not prone to ERC20 issues&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

166:         require(msg.sender == rewardsDistribution, &quot;Caller is not RewardsDistribution contract&quot;);
</code></pre>
            <pre class="solidity"><code>File: IDO/UpgradeableProxyFlattened.sol

141:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

198:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

223:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

315:         require(Address.isContract(newImplementation), &quot;UpgradeableProxy: new implementation is not a contract&quot;);

417:         require(newAdmin != address(0), &quot;TransparentUpgradeableProxy: new admin is the zero address&quot;);
</code></pre>
            <pre class="solidity"><code>File: IDO/ido.sol

49:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);
</code></pre>
            <pre class="solidity"><code>File: IDO/priceFeed.sol

61:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);
</code></pre>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

94:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

304:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

374:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

403:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

431:         require(isContract(target), &quot;Address: delegate call to non-contract&quot;);

534:             require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);

555:             require(abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);
</code></pre>
            <pre class="solidity"><code>File: Lottery/RandomNumberGenerator.sol

94:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

241:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

311:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

340:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

368:         require(isContract(target), &quot;Address: delegate call to non-contract&quot;);

471:             require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);

492:             require(abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

94:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

304:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

374:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

403:         require(isContract(target), &quot;Address: static call to non-contract&quot;);

431:         require(isContract(target), &quot;Address: delegate call to non-contract&quot;);

534:             require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);

555:             require(abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyRandomNumberGenerator.sol

21:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: TRANSFER_FROM_FAILED&#39;);

26:         require(success, &#39;TransferHelper: CLO_TRANSFER_FAILED&#39;);
</code></pre>
            <pre class="solidity"><code>File: Muticall2.sol

61:                 require(success, &quot;Multicall2 aggregate: call failed&quot;);
</code></pre>
            <pre class="solidity"><code>File: Old/CLOE_ERC20.sol

191:     require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

328:     require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

528:     require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);

529:     require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);

568:     require(account != address(0), &quot;ERC20: burn from the zero address&quot;);

589:     require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);

590:     require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);
</code></pre>
            <pre class="solidity"><code>File: Old/SOY_ERC20.sol

191:     require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

328:     require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

526:     require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);

527:     require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);

565:     require(account != address(0), &quot;ERC20: burn from the zero address&quot;);

586:     require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);

587:     require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceFactory.sol

429:         require(liquidity &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_MINTED&#39;);

450:         require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_BURNED&#39;);

464:         require(amount0Out &gt; 0 || amount1Out &gt; 0, &#39;SoyFinance: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

466:         require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY&#39;);

482:         require(amount0In &gt; 0 || amount1In &gt; 0, &#39;SoyFinance: INSUFFICIENT_INPUT_AMOUNT&#39;);
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

24:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: TRANSFER_FROM_FAILED&#39;);

29:         require(success, &#39;TransferHelper: ETH_TRANSFER_FAILED&#39;);

287:         require(tokenA != tokenB, &#39;SoyFinanceLibrary: IDENTICAL_ADDRESSES&#39;);

313:         require(amountA &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_AMOUNT&#39;);

314:         require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

320:         require(amountIn &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_INPUT_AMOUNT&#39;);

321:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

330:         require(amountOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

331:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

441:                 require(amountBOptimal &gt;= amountBMin, &#39;SoyFinanceRouter: INSUFFICIENT_B_AMOUNT&#39;);

446:                 require(amountAOptimal &gt;= amountAMin, &#39;SoyFinanceRouter: INSUFFICIENT_A_AMOUNT&#39;);

507:         require(amountA &gt;= amountAMin, &#39;SoyFinanceRouter: INSUFFICIENT_A_AMOUNT&#39;);

508:         require(amountB &gt;= amountBMin, &#39;SoyFinanceRouter: INSUFFICIENT_B_AMOUNT&#39;);

622:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

636:         require(amounts[0] &lt;= amountInMax, &#39;SoyFinanceRouter: EXCESSIVE_INPUT_AMOUNT&#39;);

652:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

666:         require(amounts[0] &lt;= amountInMax, &#39;SoyFinanceRouter: EXCESSIVE_INPUT_AMOUNT&#39;);

683:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

701:         require(amounts[0] &lt;= msg.value, &#39;SoyFinanceRouter: EXCESSIVE_INPUT_AMOUNT&#39;);

787:         require(amountOut &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

194:         require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

328:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

385:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

623:         require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);

624:         require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);

664:         require(account != address(0), &quot;ERC20: burn from the zero address&quot;);

687:         require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);

688:         require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);

786:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

909:         require(signatory != address(0), &quot;SOY::delegateBySig: invalid signature&quot;);

910:         require(nonce == nonces[signatory]++, &quot;SOY::delegateBySig: invalid nonce&quot;);

911:         require(now &lt;= expiry, &quot;SOY::delegateBySig: signature expired&quot;);

941:         require(blockNumber &lt; block.number, &quot;SOY::getPriorVotes: not yet determined&quot;);
</code></pre>
            <pre class="solidity"><code>File: Old/StakingRewards.sol

99:         require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

359:             require(abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);

433:         require(msg.sender == rewardsDistribution, &quot;Caller is not RewardsDistribution contract&quot;);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

403:         require(liquidity &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_MINTED&#39;);

424:         require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_BURNED&#39;);

438:         require(amount0Out &gt; 0 || amount1Out &gt; 0, &#39;SoyFinance: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

440:         require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY&#39;);

456:         require(amount0In &gt; 0 || amount1In &gt; 0, &#39;SoyFinance: INSUFFICIENT_INPUT_AMOUNT&#39;);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

21:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: TRANSFER_FROM_FAILED&#39;);

26:         require(success, &#39;TransferHelper: CLO_TRANSFER_FAILED&#39;);

252:         require(tokenA != tokenB, &#39;SoyFinanceLibrary: IDENTICAL_ADDRESSES&#39;);

278:         require(amountA &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_AMOUNT&#39;);

279:         require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

285:         require(amountIn &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_INPUT_AMOUNT&#39;);

286:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

295:         require(amountOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

296:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

435:                 require(amountBOptimal &gt;= amountBMin, &#39;SoyFinanceRouter: INSUFFICIENT_B_AMOUNT&#39;);

440:                 require(amountAOptimal &gt;= amountAMin, &#39;SoyFinanceRouter: INSUFFICIENT_A_AMOUNT&#39;);

503:         require(amountA &gt;= amountAMin, &#39;SoyFinanceRouter: INSUFFICIENT_A_AMOUNT&#39;);

504:         require(amountB &gt;= amountBMin, &#39;SoyFinanceRouter: INSUFFICIENT_B_AMOUNT&#39;);

620:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

634:         require(amounts[0] &lt;= amountInMax, &#39;SoyFinanceRouter: EXCESSIVE_INPUT_AMOUNT&#39;);

651:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

665:         require(amounts[0] &lt;= amountInMax, &#39;SoyFinanceRouter: EXCESSIVE_INPUT_AMOUNT&#39;);

682:         require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

701:         require(amounts[0] &lt;= msg.value, &#39;SoyFinanceRouter: EXCESSIVE_INPUT_AMOUNT&#39;);

795:         require(amountOut &gt;= amountOutMin, &#39;SoyFinanceRouter: INSUFFICIENT_OUTPUT_AMOUNT&#39;);
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

43:         require(minters[msg.sender], &quot;Only minter is allowed to do this&quot;);

49:         require(setup_mode, &quot;This is only allowed in setup mode&quot;);

187:         require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);

244:         require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);

490:         require(sender != address(0), &quot;ERC223: transfer from the zero address&quot;);

491:         require(recipient != address(0), &quot;ERC223: transfer to the zero address&quot;);

507:         require(sender != address(0), &quot;ERC223: transfer from the zero address&quot;);

508:         require(recipient != address(0), &quot;ERC223: transfer to the zero address&quot;);

548:         require(account != address(0), &quot;ERC20: burn from the zero address&quot;);

571:         require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);

572:         require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);

660:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);

810:         require(signatory != address(0), &quot;SOY::delegateBySig: invalid signature&quot;);

811:         require(nonce == nonces[signatory]++, &quot;SOY::delegateBySig: invalid nonce&quot;);

812:         require(block.timestamp &lt;= expiry, &quot;SOY::delegateBySig: signature expired&quot;);

842:         require(blockNumber &lt; block.number, &quot;SOY::getPriorVotes: not yet determined&quot;);
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

50:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);
</code></pre>
            <pre class="solidity"><code>File: Vesting.sol

61:         require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);
</code></pre>
            <h3
                id="gas-12-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable"><a
                    name="GAS-12"></a>[GAS-12]
                Functions guaranteed to revert when called by normal users can
                be marked
                <code>payable</code></h3>
            <p>If a function modifier such as <code>onlyOwner</code> is used,
                the
                function will revert if a normal user tries to pay the function.
                Marking
                the function as <code>payable</code> will lower the gas cost for
                legitimate callers because the compiler will not include checks
                for
                whether a payment was provided.</p>
            <p><em>Instances (130)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

51:     function renounceOwnership() public virtual onlyOwner {

60:     function transferOwnership(address newOwner) public virtual onlyOwner {

197:     function setSystem(address _system) onlyOwner external {

202:     function createAirdrop(uint256 amount, uint256 duration) onlyOwner external returns(uint256 airdropId) {

228:     function closeDay(uint256 airdropId, uint256 day, uint256 totalParticipants) onlySystem external {

240:     function addUsers(uint256 airdropId, uint256 day, address[] calldata users) onlySystem external {

276:     function rescueTokens(address _token) onlyOwner external {
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYGlobalFarmSimplified.sol

56:     function renounceOwnership() public onlyOwner {

65:     function transferOwnership(address newOwner) public onlyOwner {

189:     function removeLocalFarmByAddress(address _localFarmAddress) external onlyOwner {

206:     function changeMultiplier(address _localFarmAddress, uint32 _multiplier) external onlyOwner {

215:     function changeTokenPerYear(uint256 newAmount) external onlyOwner {

221:     function setGlobalMultipliers(uint256 _thisChainMultiplier, uint256 _cloTotalMultipliers) external onlyOwner {

227:     function setLocalFarm_implementation(address _localFarm_implementation) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYLocalFarm.sol

135:     function setActive(bool _status) external onlyOwner

143:     function tokenReceived(address _from, uint256 _amount, bytes memory _data) public nonReentrant onlyActive

249:     function withdrawInactiveReward() public onlyOwner

258:     function emergencyRewardWithdraw(uint256 _amount) public onlyOwner {

274:     function rescueERC20(address token, address to) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarm.sol

179:     function renounceOwnership() public onlyOwner {

188:     function transferOwnership(address newOwner) public onlyOwner {

406:     function addLocalFarm(address _localFarmAddress, uint32 _multiplier) external onlyOwner {

430:     function addLocalFarmAtID(address _localFarmAddress, uint256 _id, uint32 _multiplier) external onlyOwner {

454:     function removeLocalFarmByAddress(address _localFarmAddress) external onlyOwner {

475:     function changeMultiplier(address _localFarmAddress, uint32 _multiplier) external onlyOwner {

488:     function changeTokenPerYear(uint256 newAmount) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarmSimplified.sol

56:     function renounceOwnership() public onlyOwner {

65:     function transferOwnership(address newOwner) public onlyOwner {

147:     function addLocalFarm(address _localFarmAddress, uint32 _multiplier) external onlyOwner {

166:     function addLocalFarmAtID(address _localFarmAddress, uint256 _id, uint32 _multiplier) external onlyOwner {

190:     function removeLocalFarmByAddress(address _localFarmAddress) external onlyOwner {

207:     function changeMultiplier(address _localFarmAddress, uint32 _multiplier) external onlyOwner {

216:     function changeTokenPerYear(uint256 newAmount) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

214:     function renounceOwnership() public onlyOwner {

223:     function transferOwnership(address newOwner) public onlyOwner {

287:     function setActive(bool _status) external onlyOwner

295:     function tokenReceived(address _from, uint256 _amount, bytes memory _data) public override nonReentrant onlyActive

402:     function withdrawInactiveReward() public onlyOwner

411:     function emergencyRewardWithdraw(uint256 _amount) public onlyOwner {

427:     function rescueERC20(address token, address to) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

307:     function notifyRewardAmount(uint256 reward) external override onlyRewardsDistribution updateReward(address(0)) {
</code></pre>
            <pre class="solidity"><code>File: IDO/ido.sol

48:     function transferOwnership(address newOwner) public virtual onlyOwner {

270:     function setPause(bool state) external onlyOwner {

281:     function setLastRoundSoyPrice(uint256 val) external onlyOwner {

285:     function setMinPricePercentage(uint256 val) external onlyOwner {

289:     function setMaxPricePercentage(uint256 val) external onlyOwner {

293:     function setLockPercentage(uint256 val) external onlyOwner {

297:     function setLockPeriod(uint256 val) external onlyOwner {

301:     function setRoundDuration(uint256 val) external onlyOwner {

305:     function setMaxExtendRounds(uint256 val) external onlyOwner {

309:     function setAuctionRounds(uint256 val) external onlyOwner {

314:     function setAllowedToken(address token, bool state) external onlyOwner {

320:     function setRoundSellAmount(uint256 amount) external onlyOwner {

329:     function auctionStart(uint256 startTime, uint256 soyPrice) external onlyOwner {

596:     function rescueTokens(address _token) onlyOwner external {

608:     function burn(uint256 amount) onlyOwner external {
</code></pre>
            <pre class="solidity"><code>File: IDO/priceFeed.sol

51:     function renounceOwnership() public virtual onlyOwner {

60:     function transferOwnership(address newOwner) public virtual onlyOwner {

79:     function setSystem(address _system) onlyOwner external

92:     function setPrice(address token, uint256 price) external onlyOwnerOrSystem {

98:     function setPrices(address[] memory token, uint256[] memory price) external onlyOwnerOrSystem {
</code></pre>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

84:     function renounceOwnership() public virtual onlyOwner {

93:     function transferOwnership(address newOwner) public virtual onlyOwner {

893:     function closeLottery(uint256 _lotteryId) external override onlyOperator nonReentrant {

994:     function changeRandomGenerator(address _randomGeneratorAddress) external onlyOwner {

1016:     function injectFunds(uint256 _lotteryId, uint256 _amount) external override onlyOwnerOrInjector {

1105:     function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {

1133:     function setMaxNumberTicketsPerBuy(uint256 _maxNumberTicketsPerBuy) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Lottery/RandomNumberGenerator.sol

84:     function renounceOwnership() public virtual onlyOwner {

93:     function transferOwnership(address newOwner) public virtual onlyOwner {

901:     function setFee(uint256 _fee) external onlyOwner {

909:     function setKeyHash(bytes32 _keyHash) external onlyOwner {

917:     function setLotteryAddress(address _pancakeSwapLottery) external onlyOwner {

927:     function withdrawTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

84:     function renounceOwnership() public virtual onlyOwner {

93:     function transferOwnership(address newOwner) public virtual onlyOwner {

896:     function closeLottery(uint256 _lotteryId) external override onlyOperator nonReentrant {

997:     function changeRandomGenerator(address _randomGeneratorAddress) external onlyOwner {

1019:     function injectFunds(uint256 _lotteryId, uint256 _amount) external override onlyOwnerOrInjector {

1108:     function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {

1136:     function setMaxNumberTicketsPerBuy(uint256 _maxNumberTicketsPerBuy) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyRandomNumberGenerator.sol

77:     function renounceOwnership() public virtual onlyOwner {

211:     function commitSecret(bytes32 secretHash) external onlyOperator {

219:     function revealSecret(uint256 requestId, uint256 secret) external onlyOperator {

238:     function resetSecret() external onlyOwner {

247:     function setLotteryAddress(address _SoyLottery) external onlyOwner {

255:     function setOperatorAddress(address _operator) external onlyOwner {

265:     function withdrawTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {

284:     function testSetRandom(uint32 rnd) external onlyOperator {
</code></pre>
            <pre class="solidity"><code>File: Old/CLOE_ERC20.sol

310:   function renounceOwnership() public onlyOwner {

320:   function transferOwnership(address newOwner) public onlyOwner {

368:   function changeGateway(address gateway, bool active) external onlyOwner returns(bool) {

375:   function rescueERC20(address _token, uint256 _amount) external onlyOwner {

508:   function mint(address to, uint256 amount) public onlyGateway returns (bool) {
</code></pre>
            <pre class="solidity"><code>File: Old/SOY_ERC20.sol

310:   function renounceOwnership() public onlyOwner {

320:   function transferOwnership(address newOwner) public onlyOwner {

366:   function changeGateway(address gateway, bool active) external onlyOwner returns(bool) {

373:   function rescueERC20(address _token, uint256 _amount) external onlyOwner {

506:   function mint(address to, uint256 amount) public onlyGateway returns (bool) {
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

776:     function renounceOwnership() public virtual onlyOwner {

785:     function transferOwnership(address newOwner) public virtual onlyOwner {

802:     function mint(address _to, uint256 _amount) public onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Old/StakingRewards.sol

548:     function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {
</code></pre>
            <pre class="solidity"><code>File: Ownable.sol

56:     function renounceOwnership() public onlyOwner {

65:     function transferOwnership(address newOwner) public onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

650:     function renounceOwnership() public virtual onlyOwner {

659:     function transferOwnership(address newOwner) public virtual onlyOwner {

675:     function rescueERC20(address token, address to) external onlyOwner {

681:     function mint(address _to, uint256 _amount) public onlyMinter {

733:     function assignMinter(address _minter, bool _status) public onlyOwner onlySetupMode

739:     function disableSetup() public onlyOwner onlySetupMode
</code></pre>
            <pre class="solidity"><code>File: Staking/GobalStaking.sol

56:     function renounceOwnership() public onlyOwner {

65:     function transferOwnership(address newOwner) public onlyOwner {

225:     function removeLocalFarmByAddress(address _localFarmAddress) external onlyOwner {

242:     function changeMultiplier(address _localFarmAddress, uint32 _multiplier) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

270:     function claim() external only_staker
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

49:     function transferOwnership(address newOwner) public virtual onlyOwner {

186:     function enableStaking(bool enable) external onlyOwner {

499:     function setBonusPrices(uint256[] memory bonusPrices) external onlyOwner {

506:     function setBonusToken(address _bonusToken) external onlyOwner {

513:     function setAffiliatePercentage(uint256 _affiliatePercent, uint256 _noAffiliatePercent) external onlyOwner {

521:     function rescueTokens(address _token) onlyOwner external {
</code></pre>
            <pre class="solidity"><code>File: Vesting.sol

51:     function renounceOwnership() public virtual onlyOwner {

60:     function transferOwnership(address newOwner) public virtual onlyOwner {

206:     function setDepositor(address depositor, bool enable) external onlyOwner {

269:     function rescueTokens(address _token) onlyOwner external {
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

21:     function setSigner(address _address) external onlyOwner returns(bool) {

27:     function setDropAmount(address _token, uint256 _dropAmount) external onlyOwner returns(bool) {

41:     function airdrop(address token, uint256 amount, address[] calldata recipients) external onlyOwner returns(bool) {

48:     function airdrop2(address token, uint256[] calldata amounts, address[] calldata recipients) external onlyOwner returns(bool) {
</code></pre>
            <h3
                id="gas-13-i-costs-less-gas-than-i-especially-when-its-used-in-for-loops---ii---too"><a
                    name="GAS-13"></a>[GAS-13]
                <code>++i</code> costs less gas than <code>i++</code>,
                especially when
                it's used in <code>for</code>-loops (<code>--i</code>/<code>i--</code>
                too)</h3>
            <p><em>Saves 5 gas per loop</em></p>
            <p><em>Instances (56)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

215:         for (uint i = 0; i &lt; len; i++) {

251:         for (uint i = 0; i &lt; users.length; i++) {

266:         for (uint i = 0; i &lt; users.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYGlobalFarmSimplified.sol

170:         lastAddedFarmIndex++;
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarm.sol

270:             activeSnapshotId++;

415:         lastAddedFarmIndex++;
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarmSimplified.sol

152:         lastAddedFarmIndex++;
</code></pre>
            <pre class="solidity"><code>File: IDO/ido.sol

351:         for (uint256 i = fromRound; i&lt;toRound; i++) {

380:         for (uint256 i = 1; i &lt; toRound; i++) {

420:         for (uint256 i = 1; i &lt; currentRound; i++) {

459:         for (uint i=1; i&lt;=currentRound; i++) {

524:         currentRoundId++;

553:             currentRoundId++;

618:         for (uint256 i = 1; i &lt; currentRoundId; i++) {
</code></pre>
            <pre class="solidity"><code>File: IDO/priceFeed.sol

100:         for (uint i=0; i&lt;token.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

811:         for (uint256 i = 0; i &lt; _ticketNumbers.length; i++) {

816:             _numberTicketsPerLotteryId[_lotteryId][1 + (thisTicketNumber % 10)]++;

817:             _numberTicketsPerLotteryId[_lotteryId][11 + (thisTicketNumber % 100)]++;

818:             _numberTicketsPerLotteryId[_lotteryId][111 + (thisTicketNumber % 1000)]++;

819:             _numberTicketsPerLotteryId[_lotteryId][1111 + (thisTicketNumber % 10000)]++;

820:             _numberTicketsPerLotteryId[_lotteryId][11111 + (thisTicketNumber % 100000)]++;

821:             _numberTicketsPerLotteryId[_lotteryId][111111 + (thisTicketNumber % 1000000)]++;

828:             currentTicketId++;

854:         for (uint256 i = 0; i &lt; _ticketIds.length; i++) {

936:         for (uint32 i = 0; i &lt; 6; i++) {

1069:         currentLotteryId++;

1206:         for (uint256 i = 0; i &lt; length; i++) {

1279:         for (uint256 i = 0; i &lt; length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

812:         for (uint256 i = 0; i &lt; _ticketNumbers.length; i++) {

818:             _numberTicketsPerLotteryId[_lotteryId][1 + (thisTicketNumber % 10)]++;

819:             _numberTicketsPerLotteryId[_lotteryId][11 + (thisTicketNumber % 100)]++;

820:             _numberTicketsPerLotteryId[_lotteryId][111 + (thisTicketNumber % 1000)]++;

830:             currentTicketId++;

856:         for (uint256 i = 0; i &lt; _ticketIds.length; i++) {

939:         for (uint32 i = 0; i &lt; MAX_BRACKETS; i++) {

1072:         currentLotteryId++;

1209:         for (uint256 i = 0; i &lt; length; i++) {

1282:         for (uint256 i = 0; i &lt; length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Muticall2.sol

22:         for(uint256 i = 0; i &lt; calls.length; i++) {

57:         for(uint256 i = 0; i &lt; calls.length; i++) {
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceFactory.sol

214:                 keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

342:         for (uint i; i &lt; path.length - 1; i++) {

603:         for (uint i; i &lt; path.length - 1; i++) {

712:         for (uint i; i &lt; path.length - 1; i++) {
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

910:         require(nonce == nonces[signatory]++, &quot;SOY::delegateBySig: invalid nonce&quot;);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

235:                 keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

307:         for (uint i; i &lt; path.length - 1; i++) {

600:         for (uint i; i &lt; path.length - 1; i++) {

712:         for (uint i; i &lt; path.length - 1; i++) {
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

811:         require(nonce == nonces[signatory]++, &quot;SOY::delegateBySig: invalid nonce&quot;);
</code></pre>
            <pre class="solidity"><code>File: Staking/GobalStaking.sol

206:         lastAddedFarmIndex++;
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

274:         for (; i &lt; maxRecords; i++) {

348:         for (; i &lt; maxRecords; i++) {
</code></pre>
            <pre class="solidity"><code>File: Vesting.sol

249:         for (uint256 i = 0; i &lt; beneficiaries[beneficiary].length; i++) {
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

42:         for (uint i = 0; i &lt; recipients.length; i++) {

50:         for (uint i = 0; i &lt; recipients.length; i++) {
</code></pre>
            <h3
                id="gas-14-using-private-rather-than-public-for-constants-saves-gas"><a
                    name="GAS-14"></a>[GAS-14]
                Using <code>private</code> rather than <code>public</code> for
                constants, saves gas</h3>
            <p>If needed, the values can be read from the verified contract
                source
                code, or if there are multiple values there can be a single
                getter
                function that <a
                    href="https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178">returns
                    a tuple</a> of the values of all currently-public constants.
                Saves
                <strong>3406-3606 gas</strong> in deployment gas due to the
                compiler not
                having to create non-payable getter functions for deployment
                calldata,
                not having to store the bytes of the value outside of where it's
                used,
                and not adding another entry to the method ID table</p>
            <p><em>Instances (49)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

174:     uint256 constant public lockPeriod = 180;  // 180 days (6 months) lock period
</code></pre>
            <pre class="solidity"><code>File: BTTC/WBTT.sol

49:     string public constant name     = &quot;Wrapped BTT&quot;;

50:     string public constant symbol   = &quot;WBTT&quot;;

51:     string public constant standard = &#39;erc223&#39;;

52:     uint8  public constant decimals = 18;
</code></pre>
            <pre class="solidity"><code>File: IDO/ido.sol

217:     address constant public SoyToken = address(0x9FaE2529863bD691B4A7171bDfCf33C7ebB10a65);

218:     uint256 constant public RATIO = 1017233603000000000; // 1.017233603

219:     address constant public priceFeed = address(0x9bFc3046ea26f8B09D3E85bd22AEc96C80D957e3);   // price feed contract
</code></pre>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

679:     uint256 public constant MIN_DISCOUNT_DIVISOR = 300;

680:     uint256 public constant MIN_LENGTH_LOTTERY = 4 hours - 5 minutes; // 4 hours

681:     uint256 public constant MAX_LENGTH_LOTTERY = 4 days + 5 minutes; // 4 days

682:     uint256 public constant MAX_TREASURY_FEE = 3000; // 30%
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

680:     uint256 public constant MIN_DISCOUNT_DIVISOR = 300;

681:     uint256 public constant MIN_LENGTH_LOTTERY = 1 hours - 5 minutes; // 4 hours

682:     uint256 public constant MAX_LENGTH_LOTTERY = 4 days + 5 minutes; // 4 days

683:     uint256 public constant MAX_TREASURY_FEE = 3000; // 30%
</code></pre>
            <pre class="solidity"><code>File: Old/CLOE_ERC20.sol

343:   uint256 constant public MAX_SUPPLY = 125000000 ether;  //Max supply 125,000,000 tokens
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceFactory.sol

136:     string public constant name = &#39;SoyFinance LPs&#39;;

137:     string public constant symbol = &#39;SOY-LP&#39;;

138:     uint8 public constant decimals = 18;

145:     bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

319:     uint public constant MINIMUM_LIQUIDITY = 10**3;

514:     bytes32 public constant INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(SoyFinancePair).creationCode));
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

829:     bytes32 public constant DOMAIN_TYPEHASH = keccak256(&quot;EIP712Domain(string name,uint256 chainId,address verifyingContract)&quot;);

832:     bytes32 public constant DELEGATION_TYPEHASH = keccak256(&quot;Delegation(address delegatee,uint256 nonce,uint256 expiry)&quot;);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

144:     string public constant name = &#39;SoyFinance LPs&#39;;

145:     string public constant symbol = &#39;SOY-LP&#39;;

146:     string public constant standard = &#39;erc223&#39;;

147:     uint8 public constant decimals = 18;

154:     bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

293:     uint public constant MINIMUM_LIQUIDITY = 10**3;

496:     bytes32 public constant INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(SoyFinancePair).creationCode));
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

708:     bytes32 public constant DOMAIN_TYPEHASH = keccak256(&quot;EIP712Domain(string name,uint256 chainId,address verifyingContract)&quot;);

711:     bytes32 public constant DELEGATION_TYPEHASH = keccak256(&quot;Delegation(address delegatee,uint256 nonce,uint256 expiry)&quot;);
</code></pre>
            <pre class="solidity"><code>File: Staking/GobalStaking.sol

149:     address public constant globalFarm = 0x64Fa36ACD0d13472FD786B03afC9C52aD5FCf023;

150:     address public constant SOY_TOKEN = 0x9FaE2529863bD691B4A7171bDfCf33C7ebB10a65;
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

103:     uint public constant round_interval   = 27 days;     // 1 month.

104:     uint public constant max_delay        = 365 days;    // 1 year after staking ends.

105:     uint public constant BlockStartStaking = 7600000;

109:     address public constant SOY = 0x9FaE2529863bD691B4A7171bDfCf33C7ebB10a65;

110:     address public constant globalFarm = 0x64Fa36ACD0d13472FD786B03afC9C52aD5FCf023;
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

109:     address public constant SOY_TOKEN = 0x9FaE2529863bD691B4A7171bDfCf33C7ebB10a65;

110:     address public constant globalFarm = 0xBEefd9072712552c6dBde1bd1851699Bf2e1916f; // GlobalStaking contract

111:     uint256 public constant TIME_RESOLUTION = 1 hours;  // rewards calculates per each TIME_RESOLUTION

112:     uint256 public constant BONUS_LIMIT = 10;   // maximum bonus percentage can be bought
</code></pre>
            <pre class="solidity"><code>File: WCLO.sol

49:     string public constant name     = &quot;Wrapped CLO&quot;;

50:     string public constant symbol   = &quot;WCLO&quot;;

51:     string public constant standard = &#39;erc223&#39;;

52:     uint8  public constant decimals = 18;
</code></pre>
            <h3
                id="gas-15-use-shift-rightleft-instead-of-divisionmultiplication-if-possible"><a
                    name="GAS-15"></a>[GAS-15]
                Use shift Right/Left instead of division/multiplication if
                possible</h3>
            <p><em>Instances (4)</em>:</p>
            <pre class="solidity"><code>File: Old/SoyFinanceFactory.sol

239:             uint x = y / 2 + 1;
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

961:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

255:             uint x = y / 2 + 1;
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

862:             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
</code></pre>
            <h3
                id="gas-16-splitting-require-statements-that-use--saves-gas"><a
                    name="GAS-16"></a>[GAS-16]
                Splitting require() statements that use &amp;&amp; saves gas</h3>
            <p><em>Instances (36)</em>:</p>
            <pre class="solidity"><code>File: Farming/LocalToBridge.sol

49:         require(msg.sender == soy &amp;&amp; _from == globalFarm, &quot;sender is not allowed&quot;);
</code></pre>
            <pre class="solidity"><code>File: IDO/ido.sol

347:         require(fromRound &lt; toRound &amp;&amp; toRound &lt;= currentRoundId, &quot;Incorrect rounds parameters&quot;);

620:                 require(bets[i][newWallet].usdValue == 0 &amp;&amp; bets[i][newWallet].soyAmount == 0, &quot;newWallet already in use&quot;);
</code></pre>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

814:             require((thisTicketNumber &gt;= 1000000) &amp;&amp; (thisTicketNumber &lt;= 1999999), &quot;Outside range&quot;);
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

816:             require((thisTicketNumber &gt;= 1000) &amp;&amp; (thisTicketNumber &lt;= 1999), &quot;Outside range&quot;);
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyRandomNumberGenerator.sol

9:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: APPROVE_FAILED&#39;);

15:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: TRANSFER_FAILED&#39;);

21:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: TRANSFER_FROM_FAILED&#39;);

223:         require(commitBlock != 0 &amp;&amp; commitBlock + 1 &lt; block.number, &quot;Reveal not allowed&quot;);  // allow reveal at least in 2 blocks after commitment
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceFactory.sol

218:         require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#39;SoyFinance: INVALID_SIGNATURE&#39;);

350:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;SoyFinance: TRANSFER_FAILED&#39;);

378:         require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#39;SoyFinance: OVERFLOW&#39;);

450:         require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_BURNED&#39;);

466:         require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY&#39;);

473:         require(to != _token0 &amp;&amp; to != _token1, &#39;SoyFinance: INVALID_TO&#39;);
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

12:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: APPROVE_FAILED&#39;);

18:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: TRANSFER_FAILED&#39;);

24:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: TRANSFER_FROM_FAILED&#39;);

314:         require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

321:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

331:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

239:         require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#39;SoyFinance: INVALID_SIGNATURE&#39;);

324:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;SoyFinance: TRANSFER_FAILED&#39;);

352:         require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#39;SoyFinance: OVERFLOW&#39;);

424:         require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_BURNED&#39;);

440:         require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY&#39;);

447:         require(to != _token0 &amp;&amp; to != _token1, &#39;SoyFinance: INVALID_TO&#39;);

487:         require(_token != token0 &amp;&amp; _token != token1, &quot;Wrong token&quot;);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

9:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: APPROVE_FAILED&#39;);

15:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: TRANSFER_FAILED&#39;);

21:         require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TransferHelper: TRANSFER_FROM_FAILED&#39;);

279:         require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

286:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

296:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

483:         require(bonus !=0 &amp;&amp; bonus &lt;= bonusPrice.length, &quot;incorrect bonus&quot;);

514:         require(_affiliatePercent &lt;= 50 &amp;&amp; _noAffiliatePercent &gt;= 50 &amp;&amp; _noAffiliatePercent &lt;= 100, &quot;Wrong percentage&quot;);
</code></pre>
            <h3
                id="gas-17-use--0-instead-of--0-for-unsigned-integer-comparison"><a
                    name="GAS-17"></a>[GAS-17]
                Use != 0 instead of &gt; 0 for unsigned integer comparison</h3>
            <p><em>Instances (134)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

268:             if (u.timestamp + lockPeriod &lt;= block.timestamp &amp;&amp; u.amount &gt; 0)  {
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYLocalFarm.sol

149:         if (userInfo[_from].amount &gt; 0) {

151:             if(pending &gt; 0) {

155:         if(_amount &gt; 0) {

227:         if(pending &gt; 0) {

230:         if(_amount &gt; 0) {
</code></pre>
            <pre class="solidity"><code>File: BTTC/WBTT.sol

38:         return size &gt; 0;
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarm.sol

74:         require(value &gt; 0, &quot;Counter: decrement overflow&quot;);

119:         if (low &gt; 0 &amp;&amp; array[low - 1] == element) {

314:         require(snapshotId &gt; 0, &quot;Snapshot id is 0&quot;);

499:         require (_period &gt; 0, &quot;Cannot claim reward for a timeframe of 0 seconds&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarmSimplified.sol

245:         require (_period &gt; 0, &quot;Cannot claim reward for a timeframe of 0 seconds&quot;);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

106:         return size &gt; 0;

301:         if (userInfo[_from].amount &gt; 0) {

303:             if(pending &gt; 0) {

307:         if(_amount &gt; 0) {

380:         if(pending &gt; 0) {

383:         if(_amount &gt; 0) {
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

109:         return size &gt; 0;

214:         require(_amount &gt; 0, &quot;Cannot stake 0&quot;);

225:         require(amount &gt; 0, &quot;Cannot stake 0&quot;);

239:         require(amount &gt; 0, &quot;Cannot stake 0&quot;);

280:         require(amount &gt; 0, &quot;Cannot withdraw 0&quot;);

292:         if (reward &gt; 0) {
</code></pre>
            <pre class="solidity"><code>File: IDO/UpgradeableProxyFlattened.sol

117:         return size &gt; 0;

235:             if (returndata.length &gt; 0) {

271:         if(_data.length &gt; 0) {
</code></pre>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

280:         return size &gt; 0;

447:             if (returndata.length &gt; 0) {

552:         if (returndata.length &gt; 0) {

847:         require(_ticketIds.length != 0, &quot;Length must be &gt;0&quot;);

1134:         require(_maxNumberTicketsPerBuy != 0, &quot;Must be &gt; 0&quot;);

1173:         require(_numberTickets != 0, &quot;Number of tickets must be &gt; 0&quot;);

1348:         return size &gt; 0;
</code></pre>
            <pre class="solidity"><code>File: Lottery/RandomNumberGenerator.sol

217:         return size &gt; 0;

384:             if (returndata.length &gt; 0) {

489:         if (returndata.length &gt; 0) {
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

280:         return size &gt; 0;

447:             if (returndata.length &gt; 0) {

552:         if (returndata.length &gt; 0) {

849:         require(_ticketIds.length != 0, &quot;Length must be &gt;0&quot;);

1137:         require(_maxNumberTicketsPerBuy != 0, &quot;Must be &gt; 0&quot;);

1176:         require(_numberTickets != 0, &quot;Number of tickets must be &gt; 0&quot;);

1351:         return size &gt; 0;
</code></pre>
            <pre class="solidity"><code>File: Old/CLOE_ERC20.sol

224:     require(b &gt; 0, errorMessage);
</code></pre>
            <pre class="solidity"><code>File: Old/SOY_ERC20.sol

224:     require(b &gt; 0, errorMessage);
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceFactory.sol

5: pragma solidity &gt;=0.5.0;

26: pragma solidity &gt;=0.5.0;

82: pragma solidity &gt;=0.5.0;

277: pragma solidity &gt;=0.5.0;

298: pragma solidity &gt;=0.5.0;

378:         require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#39;SoyFinance: OVERFLOW&#39;);

381:         if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) {

405:                     if (liquidity &gt; 0) _mint(feeTo, liquidity);

429:         require(liquidity &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_MINTED&#39;);

450:         require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_BURNED&#39;);

450:         require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_BURNED&#39;);

464:         require(amount0Out &gt; 0 || amount1Out &gt; 0, &#39;SoyFinance: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

464:         require(amount0Out &gt; 0 || amount1Out &gt; 0, &#39;SoyFinance: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

474:         if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens

475:         if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens

476:         if (data.length &gt; 0) ISoyFinanceCallee(to).soyFinanceCall(msg.sender, amount0Out, amount1Out, data);

482:         require(amount0In &gt; 0 || amount1In &gt; 0, &#39;SoyFinance: INSUFFICIENT_INPUT_AMOUNT&#39;);

482:         require(amount0In &gt; 0 || amount1In &gt; 0, &#39;SoyFinance: INSUFFICIENT_INPUT_AMOUNT&#39;);
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

5: pragma solidity &gt;=0.6.0;

36: pragma solidity &gt;=0.5.0;

57: pragma solidity &gt;=0.6.2;

156: pragma solidity &gt;=0.6.2;

202: pragma solidity &gt;=0.5.0;

279: pragma solidity &gt;=0.5.0;

313:         require(amountA &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_AMOUNT&#39;);

314:         require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

314:         require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

320:         require(amountIn &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_INPUT_AMOUNT&#39;);

321:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

321:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

330:         require(amountOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

331:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

331:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

353:         for (uint i = path.length - 1; i &gt; 0; i--) {

363: pragma solidity &gt;=0.5.0;

384: pragma solidity &gt;=0.5.0;
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

228:         require(b &gt; 0, errorMessage);

398:             if (returndata.length &gt; 0) {

926:         return nCheckpoints &gt; 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;

987:         if (srcRep != dstRep &amp;&amp; amount &gt; 0) {

991:                 uint256 srcRepOld = srcRepNum &gt; 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;

999:                 uint256 dstRepOld = dstRepNum &gt; 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;

1016:         if (nCheckpoints &gt; 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
</code></pre>
            <pre class="solidity"><code>File: Old/StakingRewards.sol

117:         require(b &gt; 0, &quot;SafeMath: division by zero&quot;);

290:         return size &gt; 0;

357:         if (returndata.length &gt; 0) { // Return data is optional

505:         require(amount &gt; 0, &quot;Cannot stake 0&quot;);

517:         require(amount &gt; 0, &quot;Cannot stake 0&quot;);

525:         require(amount &gt; 0, &quot;Cannot withdraw 0&quot;);

534:         if (reward &gt; 0) {
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

2: pragma solidity &gt;=0.5.17;

27:         return size &gt; 0;

352:         require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#39;SoyFinance: OVERFLOW&#39;);

355:         if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) {

379:                     if (liquidity &gt; 0) _mint(feeTo, liquidity);

403:         require(liquidity &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_MINTED&#39;);

424:         require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_BURNED&#39;);

424:         require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#39;SoyFinance: INSUFFICIENT_LIQUIDITY_BURNED&#39;);

438:         require(amount0Out &gt; 0 || amount1Out &gt; 0, &#39;SoyFinance: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

438:         require(amount0Out &gt; 0 || amount1Out &gt; 0, &#39;SoyFinance: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

448:         if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens

449:         if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens

450:         if (data.length &gt; 0) ISoyFinanceCallee(to).soyFinanceCall(msg.sender, amount0Out, amount1Out, data);

456:         require(amount0In &gt; 0 || amount1In &gt; 0, &#39;SoyFinance: INSUFFICIENT_INPUT_AMOUNT&#39;);

456:         require(amount0In &gt; 0 || amount1In &gt; 0, &#39;SoyFinance: INSUFFICIENT_INPUT_AMOUNT&#39;);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

2: pragma solidity &gt;=0.6.6;

278:         require(amountA &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_AMOUNT&#39;);

279:         require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

279:         require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

285:         require(amountIn &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_INPUT_AMOUNT&#39;);

286:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

286:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

295:         require(amountOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_OUTPUT_AMOUNT&#39;);

296:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

296:         require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;SoyFinanceLibrary: INSUFFICIENT_LIQUIDITY&#39;);

318:         for (uint i = path.length - 1; i &gt; 0; i--) {
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

257:             if (returndata.length &gt; 0) {

827:         return nCheckpoints &gt; 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;

888:         if (srcRep != dstRep &amp;&amp; amount &gt; 0) {

892:                 uint256 srcRepOld = srcRepNum &gt; 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;

900:                 uint256 dstRepOld = dstRepNum &gt; 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;

917:         if (nCheckpoints &gt; 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

196:         require(rounds &gt; 0);

207:         if (staker_amount &gt; 0)

325:         require(staker[msg.sender].amount &gt; 0);

338:         require(staker[_addr].amount &gt; 0);
</code></pre>
            <pre class="solidity"><code>File: Vesting.sol

299:         return size &gt; 0;
</code></pre>
            <pre class="solidity"><code>File: WCLO.sol

38:         return size &gt; 0;
</code></pre>
            <h3
                id="gas-18-internal-functions-not-called-by-the-contract-should-be-removed"><a
                    name="GAS-18"></a>[GAS-18]
                <code>internal</code> functions not called by the contract
                should be
                removed</h3>
            <p>If the functions are required by an interface, the contract
                should
                inherit from that interface and use the <code>override</code>
                keyword</p>
            <p><em>Instances (18)</em>:</p>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

11:     function max(uint256 a, uint256 b) internal pure returns (uint256) {

18:     function min(uint256 a, uint256 b) internal pure returns (uint256) {

26:     function average(uint256 a, uint256 b) internal pure returns (uint256) {

98:     function isContract(address account) internal view returns (bool) {
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

14:     function max(uint256 a, uint256 b) internal pure returns (uint256) {

21:     function min(uint256 a, uint256 b) internal pure returns (uint256) {

29:     function average(uint256 a, uint256 b) internal pure returns (uint256) {

101:     function isContract(address account) internal view returns (bool) {
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

137:     function add(uint256 a, uint256 b) internal pure returns (uint256) {

185:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {

323:     function sendValue(address payable recipient, uint256 amount) internal {

701:     function _setupDecimals(uint8 decimals_) internal {
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

182:     function sendValue(address payable recipient, uint256 amount) internal {

585:     function _setupDecimals(uint8 decimals_) internal {
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

9:   function mul(uint a, uint b) internal pure returns (uint) {

18:   function div(uint a, uint b) internal pure returns (uint) {

25:   function sub(uint a, uint b) internal pure returns (uint) {

30:   function add(uint a, uint b) internal pure returns (uint) {
</code></pre>
            <h2 id="non-critical-issues">Non Critical Issues</h2>
            <table>
                <thead>
                    <tr class="header">
                        <th></th>
                        <th style="text-align: left;">Issue</th>
                        <th style="text-align: center;">Instances</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="odd">
                        <td><a href="#NC-1">NC-1</a></td>
                        <td style="text-align: left;">Missing checks for <code>address(0)</code>
                            when assigning values to address state variables</td>
                        <td style="text-align: center;">1</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#NC-2">NC-2</a></td>
                        <td
                            style="text-align: left;"><code>require()</code> /
                            <code>revert()</code> statements
                            should have descriptive reason strings</td>
                        <td style="text-align: center;">11</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#NC-3">NC-3</a></td>
                        <td style="text-align: left;">Return values of <code>approve()</code>
                            not checked</td>
                        <td style="text-align: center;">27</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#NC-4">NC-4</a></td>
                        <td style="text-align: left;">Event is missing <code>indexed</code>
                            fields</td>
                        <td style="text-align: center;">29</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#NC-5">NC-5</a></td>
                        <td style="text-align: left;">Constants should be
                            defined rather than
                            using magic numbers</td>
                        <td style="text-align: center;">7</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#NC-6">NC-6</a></td>
                        <td style="text-align: left;">Functions not used
                            internally could be
                            marked external</td>
                        <td style="text-align: center;">25</td>
                    </tr>
                </tbody>
            </table>
            <h3
                id="nc-1-missing-checks-for-address0-when-assigning-values-to-address-state-variables"><a
                    name="NC-1"></a>[NC-1]
                Missing checks for <code>address(0)</code> when assigning values
                to
                address state variables</h3>
            <p><em>Instances (1)</em>:</p>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

750:         _owner = msgSender;
</code></pre>
            <h3
                id="nc-2-require--revert-statements-should-have-descriptive-reason-strings"><a
                    name="NC-2"></a>[NC-2]
                <code>require()</code> / <code>revert()</code> statements should
                have
                descriptive reason strings</h3>
            <p><em>Instances (11)</em>:</p>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

14:     require(c / a == b);

26:     require(b &lt;= a);

32:     require(c &gt;= a);

196:         require(rounds &gt; 0);

255:         require(Timestamp &gt;= staker[user].end_time); //reject withdrawal before end time.

258:         require(_amount != 0);

325:         require(staker[msg.sender].amount &gt; 0);

331:         require(block.number &gt;= BlockStartStaking);

338:         require(staker[_addr].amount &gt; 0);

340:         require(Timestamp &gt; staker[_addr].end_time.add(max_delay));
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

49:         require(amounts.length == recipients.length);
</code></pre>
            <h3
                id="nc-3-return-values-of-approve-not-checked"><a name="NC-3"></a>[NC-3]
                Return values of <code>approve()</code> not checked</h3>
            <p>Not all IERC20 implementations <code>revert()</code> when there's
                a
                failure in <code>approve()</code>. The function signature has a
                boolean
                return value and they indicate errors that way instead. By not
                checking
                the return value, operations that should have marked as failed,
                may
                potentially go through without actually approving anything</p>
            <p><em>Instances (27)</em>:</p>
            <pre class="solidity"><code>File: Farming/LocalToBridge.sol

44:         IERC20(soy).approve(bridge, type(uint256).max);
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyRandomNumberGenerator.sol

7:         // bytes4(keccak256(bytes(&#39;approve(address,uint256)&#39;)));
</code></pre>
            <pre class="solidity"><code>File: Old/CLOE_ERC20.sol

442:     _approve(_msgSender(), spender, amount);

460:     _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, &quot;ERC20: transfer amount exceeds allowance&quot;));

477:     _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

496:     _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, &quot;ERC20: decreased allowance below zero&quot;));

604:     _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, &quot;ERC20: burn amount exceeds allowance&quot;));
</code></pre>
            <pre class="solidity"><code>File: Old/SOY_ERC20.sol

440:     _approve(_msgSender(), spender, amount);

458:     _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, &quot;ERC20: transfer amount exceeds allowance&quot;));

475:     _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

494:     _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, &quot;ERC20: decreased allowance below zero&quot;));

601:     _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, &quot;ERC20: burn amount exceeds allowance&quot;));
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceFactory.sol

191:         _approve(msg.sender, spender, value);

219:         _approve(owner, spender, value);
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

10:         // bytes4(keccak256(bytes(&#39;approve(address,uint256)&#39;)));
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

550:         _approve(_msgSender(), spender, amount);

568:         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, &quot;ERC20: transfer amount exceeds allowance&quot;));

585:         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));

604:         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, &quot;ERC20: decreased allowance below zero&quot;));
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

197:         _approve(msg.sender, spender, value);

240:         _approve(owner, spender, value);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

7:         // bytes4(keccak256(bytes(&#39;approve(address,uint256)&#39;)));
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

417:         _approve(_msgSender(), spender, amount);

435:         _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);

452:         _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);

471:         _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

183:         IERC223(SOY_TOKEN).approve(address(this), type(uint256).max); // allow contract to use transferFrom instead of transfer
</code></pre>
            <h3 id="nc-4-event-is-missing-indexed-fields"><a name="NC-4"></a>[NC-4]
                Event is missing <code>indexed</code> fields</h3>
            <p>Index event fields make the field more quickly accessible to
                off-chain tools that parse events. However, note that each index
                field
                costs extra gas during emission, so it's not necessarily best to
                index
                the maximum allowed per event (three fields). Each event should
                use
                three indexed fields if there are three or more fields, and gas
                usage is
                not particularly of concern for the events in question. If there
                are
                fewer than three fields, all of the fields should be indexed.</p>
            <p><em>Instances (29)</em>:</p>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

53:     event Transfer(address indexed from, address indexed to, uint value);

59:     event TransferData(bytes data);

243:     event RewardAdded(uint256 reward);

244:     event Staked(address indexed user, uint256 amount);

245:     event Withdraw(address indexed user, uint256 amount);

246:     event EmergencyWithdraw(address indexed user, uint256 amount);

247:     event RewardPaid(address indexed user, uint256 reward);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

56:     event Transfer(address indexed from, address indexed to, uint value);

62:     event TransferData(bytes data);

364:     event RewardAdded(uint256 reward);

365:     event Staked(address indexed user, uint256 amount);

366:     event Withdrawn(address indexed user, uint256 amount);

367:     event RewardPaid(address indexed user, uint256 reward);
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

98:     event Transfer(address indexed from, address indexed to, uint256 value);

104:     event Approval(address indexed owner, address indexed spender, uint256 value);

841:     event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

123:     event Transfer(address indexed from, address indexed to, uint256 value);

124:     event TransferData(bytes);

130:     event Approval(address indexed owner, address indexed spender, uint256 value);

720:     event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);

723:     event AssignMinter(address minter, bool status);
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

66:     event Transfer(address indexed from, address indexed to, uint value);

72:     event TransferData(bytes data);

81:     event StartStaking(address addr, uint value, uint amount, uint time, uint end_time);

82:     event WithdrawStake(address staker, uint amount);

83:     event Claim(address staker, uint reward);

84:     event DonationDeposited(address _address, uint value);
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

18:     event SetSigner(address signer);

19:     event SetDropAmount(address token, uint256 dropAmount);
</code></pre>
            <h3
                id="nc-5-constants-should-be-defined-rather-than-using-magic-numbers"><a
                    name="NC-5"></a>[NC-5]
                Constants should be defined rather than using magic numbers</h3>
            <p><em>Instances (7)</em>:</p>
            <pre class="solidity"><code>File: BTTC/SOYGlobalFarmSimplified.sol

149:         return (tokensPerYear * thisChainMultiplier) / (365 days * cloTotalMultipliers);
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

322:         uint amountInWithFee = amountIn.mul(998);

333:         uint denominator = reserveOut.sub(amountOut).mul(998);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

287:         uint amountInWithFee = amountIn.mul(998);

298:         uint denominator = reserveOut.sub(amountOut).mul(998);
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

203:         uint multiplier = (40 + (10 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]

218:                 multiplier = (40 + (5 * r)) * NOMINATOR / 100;  // staker multiplier = 0.40 + (0.05 * rounds). [0.45..1]
</code></pre>
            <h3
                id="nc-6-functions-not-used-internally-could-be-marked-external"><a
                    name="NC-6"></a>[NC-6]
                Functions not used internally could be marked external</h3>
            <p><em>Instances (25)</em>:</p>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

189:     function owner() public view returns (address) {

214:     function renounceOwnership() public onlyOwner {

223:     function transferOwnership(address newOwner) public onlyOwner {

295:     function tokenReceived(address _from, uint256 _amount, bytes memory _data) public override nonReentrant onlyActive

374:     function withdraw(uint256 _amount) public nonReentrant {

393:     function emergencyWithdraw() public nonReentrant {

402:     function withdrawInactiveReward() public onlyOwner
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

209:     function tokenReceived(address _from, uint256 _amount, bytes memory _data) public override
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

487:     function symbol() public view returns (string memory) {

504:     function decimals() public view returns (uint8) {

511:     function totalSupply() public view override returns (uint256) {

757:     function owner() public view returns (address) {

802:     function mint(address _to, uint256 _amount) public onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Ownable.sol

31:     function owner() public view returns (address) {

56:     function renounceOwnership() public onlyOwner {

65:     function transferOwnership(address newOwner) public onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

324:     function standard() public pure returns (string memory)

340:     function symbol() public view returns (string memory) {

357:     function decimals() public view returns (uint8) {

364:     function totalSupply() public view override returns (uint256) {

631:     function owner() public view returns (address) {

681:     function mint(address _to, uint256 _amount) public onlyMinter {

733:     function assignMinter(address _minter, bool _status) public onlyOwner onlySetupMode

739:     function disableSetup() public onlyOwner onlySetupMode
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

336:     function report_abuse(address payable _addr) public only_staker
</code></pre>
            <h2 id="low-issues">Low Issues</h2>
            <table>
                <thead>
                    <tr class="header">
                        <th></th>
                        <th style="text-align: left;">Issue</th>
                        <th style="text-align: center;">Instances</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="odd">
                        <td><a href="#L-1">L-1</a></td>
                        <td style="text-align: left;"><code>abi.encodePacked()</code>
                            should not
                            be used with dynamic types when passing the result
                            to a hash function
                            such as <code>keccak256()</code></td>
                        <td style="text-align: center;">16</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#L-2">L-2</a></td>
                        <td style="text-align: left;">Do not use deprecated
                            library
                            functions</td>
                        <td style="text-align: center;">7</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#L-3">L-3</a></td>
                        <td style="text-align: left;">Empty Function Body -
                            Consider commenting
                            why</td>
                        <td style="text-align: center;">8</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#L-4">L-4</a></td>
                        <td style="text-align: left;">Initializers could be
                            front-run</td>
                        <td style="text-align: center;">14</td>
                    </tr>
                    <tr class="odd">
                        <td><a href="#L-5">L-5</a></td>
                        <td style="text-align: left;">Unsafe ERC20 operation(s)</td>
                        <td style="text-align: center;">60</td>
                    </tr>
                    <tr class="even">
                        <td><a href="#L-6">L-6</a></td>
                        <td style="text-align: left;">Unspecific compiler
                            version pragma</td>
                        <td style="text-align: center;">15</td>
                    </tr>
                </tbody>
            </table>
            <h3
                id="l-1-abiencodepacked-should-not-be-used-with-dynamic-types-when-passing-the-result-to-a-hash-function-such-as-keccak256"><a
                    name="L-1"></a>[L-1]
                <code>abi.encodePacked()</code> should not be used with dynamic
                types
                when passing the result to a hash function such as
                <code>keccak256()</code></h3>
            <p>Use <code>abi.encode()</code> instead which will pad items to 32
                bytes, which will <a
                    href="https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode">prevent
                    hash collisions</a> (e.g. <code>abi.encodePacked(0x123,0x456)</code>
                =&gt; <code>0x123456</code> =&gt;
                <code>abi.encodePacked(0x1,0x23456)</code>, but
                <code>abi.encode(0x123,0x456)</code> =&gt;
                <code>0x0...1230...456</code>). "Unless there is a compelling
                reason,
                <code>abi.encode</code> should be preferred". If there is only
                one
                argument to <code>abi.encodePacked()</code> it can often be cast
                to
                <code>bytes()</code> or <code>bytes32()</code> <a
                    href="https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739">instead</a>.
                If all arguments are strings and or bytes, <code>bytes.concat()</code>
                should be used instead</p>
            <p><em>Instances (16)</em>:</p>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

899:         randomGenerator.getRandomNumber(uint256(keccak256(abi.encodePacked(_lotteryId, currentTicketId))));

999:             uint256(keccak256(abi.encodePacked(currentLotteryId, currentTicketId)))
</code></pre>
            <pre class="solidity"><code>File: Lottery/RandomNumberGenerator.sol

573:         return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

902:         randomGenerator.getRandomNumber(uint256(keccak256(abi.encodePacked(_lotteryId, currentTicketId))));

1002:             uint256(keccak256(abi.encodePacked(currentLotteryId, currentTicketId)))
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyRandomNumberGenerator.sol

221:         require(keccak256(abi.encodePacked(secret)) == entropy.secretHash, &quot;Wrong secret&quot;);

230:         uint256 randomness = uint256(keccak256(abi.encodePacked(entropy.seed, entropy.blockHash1, blockHash2, secret)));
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceFactory.sol

514:     bytes32 public constant INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(SoyFinancePair).creationCode));

538:         bytes32 salt = keccak256(abi.encodePacked(token0, token1));
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

295:         pair = address(uint(keccak256(abi.encodePacked(

298:                 keccak256(abi.encodePacked(token0, token1)),
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

496:     bytes32 public constant INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(SoyFinancePair).creationCode));

518:         bytes32 salt = keccak256(abi.encodePacked(token0, token1));
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

260:         pair = address(uint(keccak256(abi.encodePacked(

263:                 keccak256(abi.encodePacked(token0, token1)),
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

34:         require(signer == ecrecover(keccak256(abi.encodePacked(token, msg.sender, dropAmount[token])), v, r, s), &quot;ECDSA signature is not valid.&quot;);
</code></pre>
            <h3
                id="l-2-do-not-use-deprecated-library-functions"><a name="L-2"></a>[L-2]
                Do not use deprecated library functions</h3>
            <p><em>Instances (7)</em>:</p>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

502:     function safeApprove(
</code></pre>
            <pre class="solidity"><code>File: Lottery/RandomNumberGenerator.sol

439:     function safeApprove(
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

502:     function safeApprove(
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyRandomNumberGenerator.sol

6:     function safeApprove(address token, address to, uint value) internal {
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

9:     function safeApprove(address token, address to, uint value) internal {
</code></pre>
            <pre class="solidity"><code>File: Old/StakingRewards.sol

315:     function safeApprove(IERC20 token, address spender, uint256 value) internal {
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

6:     function safeApprove(address token, address to, uint value) internal {
</code></pre>
            <h3
                id="l-3-empty-function-body---consider-commenting-why"><a
                    name="L-3"></a>[L-3]
                Empty Function Body - Consider commenting why</h3>
            <p><em>Instances (8)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

152:     function tokenReceived(address _from, uint _value, bytes memory _data) external virtual {}
</code></pre>
            <pre class="solidity"><code>File: Old/CLOE_ERC20.sol

102:   constructor () internal { }
</code></pre>
            <pre class="solidity"><code>File: Old/SOY_ERC20.sol

102:   constructor () internal { }
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

719:     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

603:     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
</code></pre>
            <pre class="solidity"><code>File: Staking/GobalStaking.sol

272:     function notifyRewardAmount(uint256 reward) external {}
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

156:     function notifyRewardAmount(uint256 reward) external {}
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

199:     function notifyRewardAmount(uint256 reward) external {}
</code></pre>
            <h3 id="l-4-initializers-could-be-front-run"><a name="L-4"></a>[L-4]
                Initializers could be front-run</h3>
            <p>Initializers could be front-run, allowing an attacker to either
                set
                their own values, take ownership of the contract, and in the
                best case
                forcing a re-deployment</p>
            <p><em>Instances (14)</em>:</p>
            <pre class="solidity"><code>File: BTTC/SOYGlobalFarmSimplified.sol

90:     function initialize(

167:         ILocalFarm(_localFarmAddress).initialize(address(rewardsToken),_lpToken);
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYLocalFarm.sol

115:     function initialize(
</code></pre>
            <pre class="solidity"><code>File: Farming/Initializable.sol

46:     modifier initializer() {
</code></pre>
            <pre class="solidity"><code>File: IDO/ido.sol

249:     function initialize() external {
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceFactory.sol

76:     function initialize(address, address) external;

370:     function initialize(address _token0, address _token1) external {

542:         ISoyFinancePair(pair).initialize(token0, token1);
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

252:     function initialize(address, address) external;
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

97:     function initialize(address, address) external;

344:     function initialize(address _token0, address _token1) external {

522:         ISoyFinancePair(pair).initialize(token0, token1);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

229:     function initialize(address, address) external;
</code></pre>
            <pre class="solidity"><code>File: Staking/GobalStaking.sol

123:     function initialize(
</code></pre>
            <h3 id="l-5-unsafe-erc20-operations"><a name="L-5"></a>[L-5] Unsafe
                ERC20 operation(s)</h3>
            <p><em>Instances (60)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

270:                 token.transfer(users[i], u.amount);

278:         IERC223(_token).transfer(msg.sender, amount);
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYGlobalFarmSimplified.sol

250:             rewardsToken.transfer(_localFarmAddress, _reward);
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYLocalFarm.sol

152:                 rewardsToken.transfer(address(_from), pending);

228:             rewardsToken.transfer(address(msg.sender), pending);

232:             lpToken.transfer(address(msg.sender), _amount);

242:         lpToken.transfer(address(msg.sender), user.amount);

253:         rewardsToken.transfer(msg.sender, rewardsToken.balanceOf(address(this)));

260:         rewardsToken.transfer(address(msg.sender), _amount);

279:         IERC223(token).transfer(to, value);
</code></pre>
            <pre class="solidity"><code>File: BTTC/WBTT.sol

72:         payable(msg.sender).transfer(wad);

126:         payable(_from).transfer(_value);
</code></pre>
            <pre class="solidity"><code>File: Farming/LocalToBridge.sol

44:         IERC20(soy).approve(bridge, type(uint256).max);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

304:                 rewardsToken.transfer(address(_from), pending);

381:             rewardsToken.transfer(address(msg.sender), pending);

385:             lpToken.transfer(address(msg.sender), _amount);

395:         lpToken.transfer(address(msg.sender), user.amount);

406:         rewardsToken.transfer(msg.sender, rewardsToken.balanceOf(address(this)));

413:         rewardsToken.transfer(address(msg.sender), _amount);

432:         IERC223(token).transfer(to, value);
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYStakingRewards.sol

230:         stakingToken.transfer(msg.sender, address(this), amount);

285:         stakingToken.transfer(msg.sender, amount);

294:             rewardsToken.transfer(msg.sender, reward);
</code></pre>
            <pre class="solidity"><code>File: IDO/ido.sol

372:         IERC223(SoyToken).transfer(user, soyToClaim);

490:             IERC223(token).transferFrom(msg.sender, address(this), amount);

585:             payable(receiver).transfer(amount);

587:             IERC223(token).transfer(receiver, amount);

604:         IERC223(_token).transfer(msg.sender, amount);

614:         IERC223(SoyToken).transfer(address(0xdEad000000000000000000000000000000000000), amount);
</code></pre>
            <pre class="solidity"><code>File: Old/CLOE_ERC20.sol

376:     IERC20(_token).transfer(owner(), _amount);
</code></pre>
            <pre class="solidity"><code>File: Old/SOY_ERC20.sol

374:     IERC20(_token).transfer(owner(), _amount);
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

486:         assert(IWETH(WETH).transfer(pair, amountETH));

503:         ISoyFinancePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair

654:         assert(IWETH(WETH).transfer(SoyFinanceLibrary.pairFor(factory, path[0], path[1]), amounts[0]));

703:         assert(IWETH(WETH).transfer(SoyFinanceLibrary.pairFor(factory, path[0], path[1]), amounts[0]));

761:         assert(IWETH(WETH).transfer(SoyFinanceLibrary.pairFor(factory, path[0], path[1]), amountIn));
</code></pre>
            <pre class="solidity"><code>File: Old/WCLO.sol

41:         msg.sender.transfer(wad);
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

481:         assert(IWCLO(WCLO).transfer(pair, amountCLO));

653:         assert(IWCLO(WCLO).transfer(SoyFinanceLibrary.pairFor(factory, path[0], path[1]), amounts[0]));

703:         assert(IWCLO(WCLO).transfer(SoyFinanceLibrary.pairFor(factory, path[0], path[1]), amounts[0]));

766:         assert(IWCLO(WCLO).transfer(SoyFinanceLibrary.pairFor(factory, path[0], path[1]), amountIn));
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

677:         IERC223(token).transfer(to, value);
</code></pre>
            <pre class="solidity"><code>File: Staking/GobalStaking.sol

267:             IERC223(SOY_TOKEN).transfer(_localFarmAddress, _reward);
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStaking.sol

265:         IERC223(SOY).transfer(user, _amount);

294:             IERC223(SOY).transfer(user, _reward);

348:         IERC223(SOY).transfer(_addr, _amount);
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

183:         IERC223(SOY_TOKEN).approve(address(this), type(uint256).max); // allow contract to use transferFrom instead of transfer

250:         IERC223(SOY_TOKEN).transfer(user, userReward); // transfer rewards to user

420:         IERC223(SOY_TOKEN).transfer(user, amount + userReward);

440:             IERC223(bonusToken).transferFrom(user, address(this), amount);

451:         IERC223(SOY_TOKEN).transfer(user, userReward); // transfer rewards to user

462:             IERC223(bonusToken).transfer(address(0xdEad000000000000000000000000000000000000), amount);

474:                 IERC223(SOY_TOKEN).transferFrom(address(this), affiliate, affiliateRewardOrRest); // transfer rewards to user

524:         IERC223(_token).transfer(msg.sender, amount);
</code></pre>
            <pre class="solidity"><code>File: Vesting.sol

244:         IERC223(vestedToken).transfer(beneficiary, unlockedAmount);

277:         IERC223(_token).transfer(msg.sender, amount);
</code></pre>
            <pre class="solidity"><code>File: WCLO.sol

72:         payable(msg.sender).transfer(wad);

126:         payable(_from).transfer(_value);
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

43:             IERC20(token).transfer(recipients[i], amount);

51:             IERC20(token).transfer(recipients[i], amounts[i]);
</code></pre>
            <h3 id="l-6-unspecific-compiler-version-pragma"><a name="L-6"></a>[L-6]
                Unspecific compiler version pragma</h3>
            <p><em>Instances (15)</em>:</p>
            <pre class="solidity"><code>File: Old/SoyFinanceFactory.sol

5: pragma solidity &gt;=0.5.0;

26: pragma solidity &gt;=0.5.0;

82: pragma solidity &gt;=0.5.0;

277: pragma solidity &gt;=0.5.0;

298: pragma solidity &gt;=0.5.0;
</code></pre>
            <pre class="solidity"><code>File: Old/SoyFinanceRouter.sol

5: pragma solidity &gt;=0.6.0;

36: pragma solidity &gt;=0.5.0;

57: pragma solidity &gt;=0.6.2;

156: pragma solidity &gt;=0.6.2;

202: pragma solidity &gt;=0.5.0;

279: pragma solidity &gt;=0.5.0;

363: pragma solidity &gt;=0.5.0;

384: pragma solidity &gt;=0.5.0;
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceFactory.sol

2: pragma solidity &gt;=0.5.17;
</code></pre>
            <pre class="solidity"><code>File: SoyFinanceRouter.sol

2: pragma solidity &gt;=0.6.6;
</code></pre>
            <h2 id="medium-issues">Medium Issues</h2>
            <table>
                <thead>
                    <tr class="header">
                        <th></th>
                        <th style="text-align: left;">Issue</th>
                        <th style="text-align: center;">Instances</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="odd">
                        <td><a href="#M-1">M-1</a></td>
                        <td style="text-align: left;">Centralization Risk for
                            trusted
                            owners</td>
                        <td style="text-align: center;">149</td>
                    </tr>
                </tbody>
            </table>
            <h3
                id="m-1-centralization-risk-for-trusted-owners"><a name="M-1"></a>[M-1]
                Centralization Risk for trusted owners</h3>
            <h4 id="impact">Impact:</h4>
            <p>Contracts have owners with privileged rights to perform admin
                tasks
                and need to be trusted to not perform malicious updates or drain
                funds.</p>
            <p><em>Instances (149)</em>:</p>
            <pre class="solidity"><code>File: AirdropSoy.sol

16: abstract contract Ownable {

51:     function renounceOwnership() public virtual onlyOwner {

60:     function transferOwnership(address newOwner) public virtual onlyOwner {

155: contract Airdrop is Ownable, ERC223Recipient {

197:     function setSystem(address _system) onlyOwner external {

202:     function createAirdrop(uint256 amount, uint256 duration) onlyOwner external returns(uint256 airdropId) {

276:     function rescueTokens(address _token) onlyOwner external {
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYGlobalFarmSimplified.sol

14: contract Ownable {

56:     function renounceOwnership() public onlyOwner {

65:     function transferOwnership(address newOwner) public onlyOwner {

96: contract GlobalFarm is Ownable {

164:         external onlyOwner 

189:     function removeLocalFarmByAddress(address _localFarmAddress) external onlyOwner {

206:     function changeMultiplier(address _localFarmAddress, uint32 _multiplier) external onlyOwner {

215:     function changeTokenPerYear(uint256 newAmount) external onlyOwner {

221:     function setGlobalMultipliers(uint256 _thisChainMultiplier, uint256 _cloTotalMultipliers) external onlyOwner {

227:     function setLocalFarm_implementation(address _localFarm_implementation) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: BTTC/SOYLocalFarm.sol

258:     function emergencyRewardWithdraw(uint256 _amount) public onlyOwner {

274:     function rescueERC20(address token, address to) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarm.sol

137: contract Ownable {

179:     function renounceOwnership() public onlyOwner {

188:     function transferOwnership(address newOwner) public onlyOwner {

211: contract GlobalFarm is Ownable {

406:     function addLocalFarm(address _localFarmAddress, uint32 _multiplier) external onlyOwner {

430:     function addLocalFarmAtID(address _localFarmAddress, uint256 _id, uint32 _multiplier) external onlyOwner {

454:     function removeLocalFarmByAddress(address _localFarmAddress) external onlyOwner {

475:     function changeMultiplier(address _localFarmAddress, uint32 _multiplier) external onlyOwner {

488:     function changeTokenPerYear(uint256 newAmount) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYGlobalFarmSimplified.sol

14: contract Ownable {

56:     function renounceOwnership() public onlyOwner {

65:     function transferOwnership(address newOwner) public onlyOwner {

88: contract GlobalFarm is Ownable {

147:     function addLocalFarm(address _localFarmAddress, uint32 _multiplier) external onlyOwner {

166:     function addLocalFarmAtID(address _localFarmAddress, uint256 _id, uint32 _multiplier) external onlyOwner {

190:     function removeLocalFarmByAddress(address _localFarmAddress) external onlyOwner {

207:     function changeMultiplier(address _localFarmAddress, uint32 _multiplier) external onlyOwner {

216:     function changeTokenPerYear(uint256 newAmount) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Farming/SOYLocalFarm.sol

172: contract Ownable {

214:     function renounceOwnership() public onlyOwner {

223:     function transferOwnership(address newOwner) public onlyOwner {

411:     function emergencyRewardWithdraw(uint256 _amount) public onlyOwner {

427:     function rescueERC20(address token, address to) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: IDO/ido.sol

16: abstract contract Ownable {

48:     function transferOwnership(address newOwner) public virtual onlyOwner {

196: contract IDO is Ownable, ReentrancyGuard {

270:     function setPause(bool state) external onlyOwner {

274:     function setBank(address payable _bank) onlyOwner external

281:     function setLastRoundSoyPrice(uint256 val) external onlyOwner {

285:     function setMinPricePercentage(uint256 val) external onlyOwner {

289:     function setMaxPricePercentage(uint256 val) external onlyOwner {

293:     function setLockPercentage(uint256 val) external onlyOwner {

297:     function setLockPeriod(uint256 val) external onlyOwner {

301:     function setRoundDuration(uint256 val) external onlyOwner {

305:     function setMaxExtendRounds(uint256 val) external onlyOwner {

309:     function setAuctionRounds(uint256 val) external onlyOwner {

314:     function setAllowedToken(address token, bool state) external onlyOwner {

320:     function setRoundSellAmount(uint256 amount) external onlyOwner {

329:     function auctionStart(uint256 startTime, uint256 soyPrice) external onlyOwner {

596:     function rescueTokens(address _token) onlyOwner external {

608:     function burn(uint256 amount) onlyOwner external {
</code></pre>
            <pre class="solidity"><code>File: IDO/priceFeed.sol

16: abstract contract Ownable {

51:     function renounceOwnership() public virtual onlyOwner {

60:     function transferOwnership(address newOwner) public virtual onlyOwner {

67: contract PriceFeed is Ownable {

79:     function setSystem(address _system) onlyOwner external
</code></pre>
            <pre class="solidity"><code>File: Lottery/PancakeSwapLottery.sol

48: abstract contract Ownable is Context {

84:     function renounceOwnership() public virtual onlyOwner {

93:     function transferOwnership(address newOwner) public virtual onlyOwner {

662: contract PancakeSwapLottery is ReentrancyGuard, IPancakeSwapLottery, Ownable {

994:     function changeRandomGenerator(address _randomGeneratorAddress) external onlyOwner {

1105:     function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {

1133:     function setMaxNumberTicketsPerBuy(uint256 _maxNumberTicketsPerBuy) external onlyOwner {

1149:     ) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Lottery/RandomNumberGenerator.sol

48: abstract contract Ownable is Context {

84:     function renounceOwnership() public virtual onlyOwner {

93:     function transferOwnership(address newOwner) public virtual onlyOwner {

863: contract RandomNumberGenerator is VRFConsumerBase, IRandomNumberGenerator, Ownable {

901:     function setFee(uint256 _fee) external onlyOwner {

909:     function setKeyHash(bytes32 _keyHash) external onlyOwner {

917:     function setLotteryAddress(address _pancakeSwapLottery) external onlyOwner {

927:     function withdrawTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyLottery.sol

48: abstract contract Ownable is Context {

84:     function renounceOwnership() public virtual onlyOwner {

93:     function transferOwnership(address newOwner) public virtual onlyOwner {

662: contract SoyLottery is ReentrancyGuard, ISoyLottery, Ownable {

997:     function changeRandomGenerator(address _randomGeneratorAddress) external onlyOwner {

1108:     function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {

1136:     function setMaxNumberTicketsPerBuy(uint256 _maxNumberTicketsPerBuy) external onlyOwner {

1152:     ) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Lottery/SoyRandomNumberGenerator.sol

42: abstract contract Ownable {

77:     function renounceOwnership() public virtual onlyOwner {

169: contract RandomNumberGenerator is IRandomNumberGenerator, Ownable {

238:     function resetSecret() external onlyOwner {

247:     function setLotteryAddress(address _SoyLottery) external onlyOwner {

255:     function setOperatorAddress(address _operator) external onlyOwner {

265:     function withdrawTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Old/CLOE_ERC20.sol

275: contract Ownable is Context {

310:   function renounceOwnership() public onlyOwner {

320:   function transferOwnership(address newOwner) public onlyOwner {

334: contract ERC20Token is Context, IERC20, Ownable {

368:   function changeGateway(address gateway, bool active) external onlyOwner returns(bool) {

375:   function rescueERC20(address _token, uint256 _amount) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Old/SOY_ERC20.sol

275: contract Ownable is Context {

310:   function renounceOwnership() public onlyOwner {

320:   function transferOwnership(address newOwner) public onlyOwner {

334: contract ERC20Token is Context, IERC20, Ownable {

366:   function changeGateway(address gateway, bool active) external onlyOwner returns(bool) {

373:   function rescueERC20(address _token, uint256 _amount) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Old/Soy_Token_sushifork.sol

740: contract Ownable is Context {

776:     function renounceOwnership() public virtual onlyOwner {

785:     function transferOwnership(address newOwner) public virtual onlyOwner {

800: contract SoyToken is ERC20(&quot;SOY Finance&quot;, &quot;SOY&quot;), Ownable {

802:     function mint(address _to, uint256 _amount) public onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Ownable.sol

14: contract Ownable {

56:     function renounceOwnership() public onlyOwner {

65:     function transferOwnership(address newOwner) public onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: SoyTokenERC223.sol

619: contract Ownable is Context {

650:     function renounceOwnership() public virtual onlyOwner {

659:     function transferOwnership(address newOwner) public virtual onlyOwner {

674: contract SoyToken is ERC223(&quot;SOY Finance token&quot;, &quot;SOY&quot;), Ownable {

675:     function rescueERC20(address token, address to) external onlyOwner {

733:     function assignMinter(address _minter, bool _status) public onlyOwner onlySetupMode

739:     function disableSetup() public onlyOwner onlySetupMode
</code></pre>
            <pre class="solidity"><code>File: Staking/GobalStaking.sol

14: contract Ownable {

56:     function renounceOwnership() public onlyOwner {

65:     function transferOwnership(address newOwner) public onlyOwner {

141: contract GlobalStaking is Ownable {

202:         external onlyOwner 

225:     function removeLocalFarmByAddress(address _localFarmAddress) external onlyOwner {

242:     function changeMultiplier(address _localFarmAddress, uint32 _multiplier) external onlyOwner {
</code></pre>
            <pre class="solidity"><code>File: Staking/SoyStakingV2.sol

17: abstract contract Ownable {

49:     function transferOwnership(address newOwner) public virtual onlyOwner {

108: contract SoyStaking is Ownable {

186:     function enableStaking(bool enable) external onlyOwner {

499:     function setBonusPrices(uint256[] memory bonusPrices) external onlyOwner {

506:     function setBonusToken(address _bonusToken) external onlyOwner {

513:     function setAffiliatePercentage(uint256 _affiliatePercent, uint256 _noAffiliatePercent) external onlyOwner {

521:     function rescueTokens(address _token) onlyOwner external {
</code></pre>
            <pre class="solidity"><code>File: Vesting.sol

16: abstract contract Ownable {

51:     function renounceOwnership() public virtual onlyOwner {

60:     function transferOwnership(address newOwner) public virtual onlyOwner {

175: contract Vesting is Ownable, ERC223Recipient {

206:     function setDepositor(address depositor, bool enable) external onlyOwner {

269:     function rescueTokens(address _token) onlyOwner external {
</code></pre>
            <pre class="solidity"><code>File: airdrop.sol

12: contract Airdrop is Ownable {

21:     function setSigner(address _address) external onlyOwner returns(bool) {

27:     function setDropAmount(address _token, uint256 _dropAmount) external onlyOwner returns(bool) {

41:     function airdrop(address token, uint256 amount, address[] calldata recipients) external onlyOwner returns(bool) {

48:     function airdrop2(address token, uint256[] calldata amounts, address[] calldata recipients) external onlyOwner returns(bool) {
</code></pre>

        </article>
    </body>
</html>